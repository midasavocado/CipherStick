<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flux - AI Shortcut Generator</title>
    <meta name="description"
        content="Build Apple Shortcuts with AI. Flux turns natural language into powerful automation workflows.">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ö°Ô∏è</text></svg>">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/utilities.css">
    <link rel="stylesheet" href="css/animations.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/pages/app.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>

<body class="mode-dark">
    <div class="app-container">
        <!-- Top Navigation Bar -->
        <nav class="top-bar" style="padding: 0 1.5rem;">
            <a href="index.html" class="logo-area" style="text-decoration: none; color: inherit;">
                <div class="logo-icon">F</div>
                <span>Flux</span>
            </a>
            <div class="nav-actions flex items-center gap-4">
                <button class="toolbar-btn primary" id="top-download-btn" onclick="openDownloadModal()">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Download
                </button>
                <div class="dropdown" id="profile-dropdown">
                    <button class="user-profile-btn" onclick="toggleProfileMenu()">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                            <circle cx="12" cy="7" r="4"></circle>
                        </svg>
                    </button>
                    <div class="dropdown-menu" id="profile-menu">
                        <div class="dropdown-item" onclick="window.location.href='settings.html'"><svg width="16"
                                height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path
                                    d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                                </path>
                            </svg>Settings</div>
                        <div class="dropdown-item" onclick="window.location.href='pricing.html'"><svg width="16"
                                height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon
                                    points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2">
                                </polygon>
                            </svg>Upgrade to Pro</div>
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-item" onclick="toggleTheme()"><svg width="16" height="16"
                                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                            </svg>Toggle Theme</div>
                        <div class="dropdown-item" onclick="toggleAnimations()"><svg width="16" height="16"
                                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M8 12l2 2 4-4"></path>
                            </svg><span id="animations-toggle-text">Disable Animations</span></div>
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-item" onclick="startTutorial()"><svg width="16" height="16"
                                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                                <line x1="12" y1="17" x2="12.01" y2="17"></line>
                            </svg>Replay Tutorial</div>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Main App Content -->
        <main class="app-main">
            <!-- Projects Dashboard View -->
            <div id="projects-view" class="projects-dashboard">
                <div class="dashboard-header">
                    <h1>Your Projects</h1>
                    <p>Build and manage your Apple Shortcuts</p>
                </div>
                <div id="projects-grid" class="projects-grid">
                    <div class="project-card new-project-card" onclick="createNewProject()">
                        <div class="plus-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                        </div>
                        <span>New Project</span>
                    </div>
                </div>
            </div>

            <!-- Workspace View -->
            <div id="workspace-view" class="workspace hidden">
                <!-- Chat Pane -->
                <aside class="chat-pane" id="chat-pane">
                    <div class="chat-header">
                        <button class="back-btn" onclick="showProjectsView()" title="Back to Projects">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M19 12H5"></path>
                                <polyline points="12 19 5 12 12 5"></polyline>
                            </svg>
                        </button>
                        <span style="font-weight: 600; color: var(--heading-color);">Builder</span>
                    </div>

                    <!-- Pipeline Orbs (inline in chat) -->

                    <div class="messages-container" id="messages"></div>

                    <!-- Chat Input Area -->
    <div class="chat-input-area">
        <div class="plus-menu" id="plus-menu">
            <div class="plus-menu-item" onclick="event.stopPropagation(); openForceActionModal();">
                <div class="item-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg></div>
                <div class="item-content">
                    <div class="item-title">Force Action <span class="pro-badge">PRO</span></div>
                    <div class="item-desc">Add a specific action to your shortcut</div>
                </div>
            </div>
            <div class="plus-menu-item" id="discussion-mode-toggle"
                onclick="event.stopPropagation(); toggleMode('discussion');">
                <div class="item-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg></div>
                <div class="item-content">
                    <div class="item-title">Discussion Mode</div>
                    <div class="item-desc">Chat without modifying shortcut</div>
                </div>
            </div>
        </div>
                        <!-- Forced Actions Display -->
                        <div class="forced-actions" id="forced-actions"></div>
                        <div class="chat-input-wrapper">
                            <button class="plus-menu-btn" id="plus-menu-btn"
                                onclick="event.stopPropagation(); togglePlusMenu();">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </button>
                            <textarea id="chat-input" class="chat-input" placeholder="Describe your shortcut..."
                                rows="1"></textarea>
                            <button class="send-btn" id="send-btn" onclick="handleSend()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                                </svg>
                            </button>
                        </div>
                        <div class="chat-extras" style="display:none;">
                            <div class="markdown-preview" id="markdown-preview" style="display:none;"></div>
                        </div>
                    </div>
                    <div class="resize-handle" id="resize-handle"></div>
                </aside>

                <!-- Preview Pane -->
                <section class="preview-pane">
                    <div class="preview-toolbar">
                        <input type="text" id="project-name-input" class="project-name-input"
                            placeholder="Untitled Project" value="Untitled Project">
	                        <div class="toolbar-actions">
	                            <button class="toolbar-btn icon-only" id="undo-btn" onclick="undoWorkspace()" title="Undo (‚åòZ)" disabled style="display:none;">
	                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
	                                    <polyline points="1 4 1 10 7 10"></polyline>
	                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
	                                </svg>
	                            </button>
	                            <button class="toolbar-btn icon-only" id="redo-btn" onclick="redoWorkspace()" title="Redo (‚áß‚åòZ)" disabled style="display:none;">
	                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
	                                    <polyline points="23 4 23 10 17 10"></polyline>
	                                    <path d="M20.49 15a9 9 0 1 1-2.13-9.36L23 10"></path>
	                                </svg>
	                            </button>
	                            <button class="toolbar-btn" id="add-action-btn" onclick="openForceActionModal()"
	                                style="display: none;">
	                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
	                                    stroke-width="2">
	                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                                Add Action
                            </button>
                            <button class="toolbar-btn" id="edit-btn" onclick="toggleEditMode()">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                                <span id="edit-btn-text">Edit</span>
                            </button>
                        </div>
                    </div>
                    <div class="preview-canvas" id="preview-canvas">
                        <div class="empty-state" id="empty-state">
                            <div class="icon"><svg width="32" height="32" viewBox="0 0 24 24" fill="none"
                                    stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                                    <path d="M2 17l10 5 10-5"></path>
                                    <path d="M2 12l10 5 10-5"></path>
                                </svg></div>
                            <h3>Start Building</h3>
                            <p>Describe your shortcut in the chat and watch it come to life.</p>
                        </div>
                        <div id="actions-container" class="hidden"></div>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <!-- Force Action Modal -->
    <div id="force-action-modal" class="modal-overlay">
        <div class="modal-card" style="max-width: 600px; max-height: 80vh;">
            <div class="modal-header">
                <h3>Force Action</h3>
                <button class="modal-close" onclick="closeForceActionModal()"><svg width="16" height="16"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg></button>
            </div>
            <input type="text" id="action-search" class="input-glass" placeholder="Search actions..."
                style="margin-bottom: 1rem; width: 100%;">
            <div id="actions-list"
                style="max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;"></div>
        </div>
    </div>

    <!-- Download Modal -->
    <!-- Delete Confirmation Modal -->
    <div id="delete-modal" class="modal-overlay">
        <div class="modal-card">
            <div class="modal-header">
                <h3>Delete Action?</h3>
                <button class="modal-close" onclick="closeDeleteModal()"><svg width="16" height="16" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this action? This cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" onclick="closeDeleteModal()">Cancel</button>
                <button class="btn danger" onclick="confirmDeleteAction()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Download Modal -->
    <div id="download-modal" class="modal-overlay">
        <div class="modal-card">
            <div class="modal-header">
                <h3>Download Shortcut</h3>
                <button class="modal-close" onclick="closeDownloadModal()"><svg width="16" height="16"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg></button>
            </div>
            <div id="download-status"
                style="display: none; padding: 1rem; background: var(--surface-hover); border-radius: 8px; margin-bottom: 1rem;">
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <div class="typing-indicator"><span></span><span></span><span></span></div>
                    <span id="download-status-text">Generating shortcut...</span>
                </div>
            </div>
            <div class="download-options">
                <div class="download-option disabled" id="download-private-option"
                    style="opacity: 0.5; cursor: not-allowed;">
                    <div class="option-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2">
                            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                        </svg></div>
                    <div class="option-content">
                        <h4>Download Private <span class="pro-badge">PRO</span></h4>
                        <p>Download for personal use. Chat history stays private.</p>
                    </div>
                </div>
                <div class="download-option" onclick="executeDownload('publish')">
                    <div class="option-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="2" y1="12" x2="22" y2="12"></line>
                            <path
                                d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z">
                            </path>
                        </svg></div>
                    <div class="option-content">
                        <h4>Download &amp; Publish</h4>
                        <p>Share with the community. Shortcut only, no chat.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Variable Context Menu -->
    <div id="variable-context-menu" class="context-menu">
        <div class="context-menu-header">Insert Variable</div>
        <div class="context-menu-item" onclick="insertVariable('Shortcut Input')">üì• Shortcut Input</div>
        <div class="context-menu-item" onclick="insertVariable('Clipboard')">üìã Clipboard</div>
        <div class="context-menu-item" onclick="insertVariable('Current Date')">üìÖ Current Date</div>
        <div class="context-menu-item" onclick="insertVariable('Device Name')">üì± Device Name</div>
        <div class="context-menu-item" onclick="insertVariable('Ask Each Time')">‚ùì Ask Each Time</div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="tutorial-overlay">
        <div class="tutorial-spotlight" id="tutorial-spotlight"></div>
        <div class="tutorial-popup" id="tutorial-popup">
            <div class="tutorial-step-indicator" id="tutorial-indicator"></div>
            <h3 id="tutorial-title">Welcome to Flux!</h3>
            <p id="tutorial-text">Let's take a quick tour of how to build shortcuts with AI.</p>
            <div class="tutorial-actions">
                <button class="tutorial-skip" onclick="skipTutorial()">Skip Tutorial</button>
                <button class="tutorial-next" id="tutorial-next" onclick="nextTutorialStep()">Next</button>
            </div>
        </div>
    </div>

    <script src="theme.js"></script>
    <script src="flux-ui.js"></script>
    <script>
        // ============ Configuration ============
        const API_BASE = 'https://secrets.mwsaulsbury.workers.dev';
        const IS_PRO_USER = false; // Set to true for pro users

	        // ============ State ============
	        let currentProject = null;
	        let projects = JSON.parse(localStorage.getItem('flux_projects')) || [];
	        let chatMode = 'standard'; // 'standard', 'discussion'
	        let availableTemplates = [];
	        let currentActions = [];
		let currentProgramObj = null;
		let isGenerating = false;
		let editMode = false;
		let forcedActions = [];
	        let undoStack = [];
	        let redoStack = [];
	        let isRestoringHistory = false;
	        const MAX_HISTORY_STATES = 80;
		let reorderState = null;
		let reorderListenersAttached = false;
		let animationsEnabled = localStorage.getItem('flux_animations') !== 'disabled';
		        let contextMenuTarget = null;
		        let tutorialStep = 0;
	        let hasCompletedTutorial = localStorage.getItem('flux_tutorial_done') === 'true';
	        const DEFAULT_CONDITION_OPTIONS = 'Is/Is Not/Has Any Value/Does Not Have Any Value/Contains/Does Not Contain/Begins With/Ends With/Is Greater Than/Is Greater Than Or Equal To/Is Less Than/Is Less Than Or Equal To';

        // ============ Init ============
        document.addEventListener('DOMContentLoaded', () => {
            initApp();
            initTheme();
            initResizeHandle();
            loadTemplates();
            initEventListeners();
        });

        function initApp() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectId = urlParams.get('id');
            const initialPrompt = urlParams.get('prompt');
            if (projectId) {
                loadProject(projectId);
            } else if (initialPrompt) {
                createNewProject(initialPrompt);
            } else {
                showProjectsView();
            }
        }

	        function initEventListeners() {
	            document.getElementById('chat-input')?.addEventListener('input', function () {
	                this.style.height = 'auto';
	                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
	            });
            document.getElementById('chat-input')?.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSend();
                }
            });
	            document.getElementById('project-name-input')?.addEventListener('blur', function () {
	                if (!currentProject) return;
	                const nextName = this.value.trim();
	                if (!nextName) return;
	                if (nextName !== currentProject.name) {
	                    pushUndoState();
	                    currentProject.name = nextName;
	                    saveProjects();
	                }
	            });
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#plus-menu') && !e.target.closest('#plus-menu-btn')) {
                    document.getElementById('plus-menu')?.classList.remove('active');
                    document.getElementById('plus-menu-btn')?.classList.remove('active');
                }
                if (!e.target.closest('#profile-dropdown')) {
                    document.getElementById('profile-menu')?.classList.remove('active');
                }
            });
	            document.getElementById('chat-input')?.addEventListener('input', updateMarkdownPreview);

	            document.addEventListener('keydown', (e) => {
	                if (!currentProject) return;
	                const key = String(e.key || '').toLowerCase();
	                const isModifier = e.metaKey || e.ctrlKey;
	                if (!isModifier || e.altKey) return;
	                const target = e.target;
	                if (target?.closest && target.closest('input, textarea, select, [contenteditable="true"]')) {
	                    return;
	                }
	                if (key === 'z') {
	                    e.preventDefault();
	                    if (e.shiftKey) redoWorkspace();
	                    else undoWorkspace();
	                    return;
	                }
	                if (key === 'y') {
	                    e.preventDefault();
	                    redoWorkspace();
	                }
	            });

	            updateUndoRedoButtons();
	        }

        function initTheme() {
            if (!localStorage.getItem('flux_theme')) {
                document.body.classList.add('mode-dark');
                localStorage.setItem('flux_theme', 'dark');
            } else {
                const theme = localStorage.getItem('flux_theme');
                document.body.classList.toggle('mode-dark', theme === 'dark');
            }
            updateThemeIcon();
        }

        function toggleTheme() {
            document.body.classList.toggle('mode-dark');
            localStorage.setItem('flux_theme', document.body.classList.contains('mode-dark') ? 'dark' : 'light');
            updateThemeIcon();
        }

        function updateThemeIcon() {
            const sunIcon = document.getElementById('theme-icon-sun');
            const moonIcon = document.getElementById('theme-icon-moon');
            const isDark = document.body.classList.contains('mode-dark');
            if (sunIcon) sunIcon.style.display = isDark ? 'block' : 'none';
            if (moonIcon) moonIcon.style.display = isDark ? 'none' : 'block';
        }

        // ============ Views ============
        function showProjectsView() {
            document.getElementById('projects-view').classList.remove('hidden');
            document.getElementById('workspace-view').classList.add('hidden');
            window.history.replaceState({}, '', 'app.html');
            renderProjectsGrid();
        }

        function showWorkspaceView() {
            document.getElementById('projects-view').classList.add('hidden');
            document.getElementById('workspace-view').classList.remove('hidden');
        }

        // ============ Projects ============
        function renderProjectsGrid() {
            const grid = document.getElementById('projects-grid');
            if (!grid) return;
            const newCard = grid.querySelector('.new-project-card');
            grid.innerHTML = '';
            if (newCard) grid.appendChild(newCard);

            projects.forEach(p => {
                const card = document.createElement('div');
                card.className = 'project-card';
                card.onclick = () => loadProject(p.id);
                const date = new Date(p.updated).toLocaleDateString();
                const actionCount = p.actions ? p.actions.length : 0;
                card.innerHTML = `
                    <h3>${escapeHtml(p.name)}</h3>
                    <div class="project-meta"><span>${date}</span><span>${actionCount} actions</span></div>
                    <div class="project-actions">
                        <button class="node-action-btn delete" onclick="event.stopPropagation(); deleteProject('${p.id}')" title="Delete">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        function createNewProject(initialPrompt = null) {
            const id = 'proj_' + Date.now();
            const newProject = {
                id,
                name: 'New Shortcut',
                created: Date.now(),
                updated: Date.now(),
                history: [],
                actions: [],
                programObj: null
            };
            projects.unshift(newProject);
            saveProjects();
            loadProject(id);
            if (initialPrompt) {
                setTimeout(() => {
                    document.getElementById('chat-input').value = initialPrompt;
                    handleSend();
                }, 300);
            }
        }

	        function loadProject(id) {
	            currentProject = projects.find(p => p.id === id);
	            if (!currentProject) { showProjectsView(); return; }
	            currentActions = ensureActionUUIDs(currentProject.actions || []);
	            currentProject.actions = currentActions;
	            saveProjects();
	            currentProgramObj = currentProject.programObj || null;
	            resetUndoRedoHistory();
	            showWorkspaceView();
	            document.getElementById('project-name-input').value = currentProject.name;
	            window.history.replaceState({}, '', `app.html?id=${id}`);
            const messagesEl = document.getElementById('messages');
            messagesEl.innerHTML = '';
            // No welcome message - show empty state instead
	            if (currentProject.history.length > 0) {
	                currentProject.history.forEach(msg => addMessageToUI(msg.content, msg.role));
	            }
	            renderActions();
	            updateUndoRedoButtons();
	        }

	        function saveProjects() {
	            localStorage.setItem('flux_projects', JSON.stringify(projects));
	        }

	        function clonePlainObject(value) {
	            try {
	                if (typeof structuredClone === 'function') return structuredClone(value);
	            } catch (e) { }
	            return JSON.parse(JSON.stringify(value));
	        }

	        function captureWorkspaceState() {
	            return {
	                name: currentProject?.name || '',
	                actions: clonePlainObject(currentActions || [])
	            };
	        }

	        function applyWorkspaceState(state) {
	            if (!state || typeof state !== 'object') return;
	            currentActions = ensureActionUUIDs(clonePlainObject(state.actions || []));
	            if (currentProject) {
	                if (typeof state.name === 'string' && state.name.trim()) {
	                    currentProject.name = state.name.trim();
	                    const nameInput = document.getElementById('project-name-input');
	                    if (nameInput) nameInput.value = currentProject.name;
	                }
	                currentProject.actions = currentActions;
	                saveProjects();
	            }
	            renderActions();
	        }

	        function resetUndoRedoHistory() {
	            undoStack = [];
	            redoStack = [];
	            updateUndoRedoButtons();
	        }

	        function updateUndoRedoButtons() {
	            const undoBtn = document.getElementById('undo-btn');
	            const redoBtn = document.getElementById('redo-btn');
	            const shouldShow = !!currentProject && !!editMode;
	            if (undoBtn) {
	                undoBtn.disabled = !currentProject || undoStack.length === 0;
	                undoBtn.style.display = shouldShow ? 'inline-flex' : 'none';
	            }
	            if (redoBtn) {
	                redoBtn.disabled = !currentProject || redoStack.length === 0;
	                redoBtn.style.display = shouldShow ? 'inline-flex' : 'none';
	            }
	        }

	        function pushUndoSnapshot(snapshot) {
	            if (isRestoringHistory) return;
	            if (!currentProject) return;
	            if (!snapshot || typeof snapshot !== 'object') return;
	            undoStack.push(clonePlainObject(snapshot));
	            if (undoStack.length > MAX_HISTORY_STATES) undoStack.shift();
	            redoStack = [];
	            updateUndoRedoButtons();
	        }

	        function pushUndoState() {
	            pushUndoSnapshot(captureWorkspaceState());
	        }

	        function undoWorkspace() {
	            if (!currentProject) return;
	            if (undoStack.length === 0) return;
	            isRestoringHistory = true;
	            redoStack.push(captureWorkspaceState());
	            const prev = undoStack.pop();
	            applyWorkspaceState(prev);
	            isRestoringHistory = false;
	            updateUndoRedoButtons();
	        }

	        function redoWorkspace() {
	            if (!currentProject) return;
	            if (redoStack.length === 0) return;
	            isRestoringHistory = true;
	            undoStack.push(captureWorkspaceState());
	            const next = redoStack.pop();
	            applyWorkspaceState(next);
	            isRestoringHistory = false;
	            updateUndoRedoButtons();
	        }

        function genUUID() {
            return (crypto?.randomUUID?.() || ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            ));
        }

        function ensureActionUUIDs(actions = []) {
            return actions.map(a => {
                if (!a.id) a.id = Date.now() + Math.floor(Math.random() * 100000);
                if (!a.params) a.params = {};
                const currentUuid = typeof a.params.UUID === 'string' ? a.params.UUID.trim() : '';
                if (!currentUuid) {
                    const fromOutputUUID = typeof a.params.OutputUUID === 'string' ? a.params.OutputUUID.trim() : '';
                    const fromProvided = typeof a.params.ProvidedOutputUUID === 'string' ? a.params.ProvidedOutputUUID.trim() : '';
                    a.params.UUID = fromOutputUUID || fromProvided || genUUID();
                } else {
                    a.params.UUID = currentUuid;
                }
                if (a.params.ProvidedOutputUUID) delete a.params.ProvidedOutputUUID;
                if (!a.params.GroupingIdentifier && isControlAction(a)) {
                    a.params.GroupingIdentifier = genUUID();
                }
                if (Array.isArray(a.then)) a.then = ensureActionUUIDs(a.then);
                if (Array.isArray(a.else)) a.else = ensureActionUUIDs(a.else);
                if (Array.isArray(a.do)) a.do = ensureActionUUIDs(a.do);
                return a;
            });
        }

        function findActionLocation(actionId, actions = currentActions, parentAction = null, parentArray = currentActions, section = 'root') {
            if (!Array.isArray(actions)) return null;
            for (let i = 0; i < actions.length; i++) {
                const action = actions[i];
                if (action.id === actionId) {
                    return { action, parentAction, parentArray, section, index: i };
                }
                if (isConditionalAction(action)) {
                    const inThen = findActionLocation(actionId, action.then || [], action, action.then || [], 'then');
                    if (inThen) return inThen;
                    const inElse = findActionLocation(actionId, action.else || [], action, action.else || [], 'else');
                    if (inElse) return inElse;
                }
                if (isRepeatAction(action)) {
                    const inDo = findActionLocation(actionId, action.do || [], action, action.do || [], 'do');
                    if (inDo) return inDo;
                }
            }
            return null;
        }

        function actionContainsId(action, targetId) {
            if (!action) return false;
            const checkArray = (arr) => Array.isArray(arr) && arr.some(a => a?.id === targetId || actionContainsId(a, targetId));
            return checkArray(action.then) || checkArray(action.else) || checkArray(action.do);
        }

        function removeActionById(actionId) {
            const loc = findActionLocation(actionId);
            if (!loc) return null;
            const [removed] = loc.parentArray.splice(loc.index, 1);
            return removed || loc.action;
        }

        function ensureSectionArray(action, sectionKey) {
            if (!action) return null;
            if (sectionKey === 'then') {
                if (!Array.isArray(action.then)) action.then = [];
                return action.then;
            }
            if (sectionKey === 'else') {
                if (!Array.isArray(action.else)) action.else = [];
                return action.else;
            }
            if (sectionKey === 'do') {
                if (!Array.isArray(action.do)) action.do = [];
                return action.do;
            }
            return currentActions;
        }

        function cloneActionDeep(action) {
            const cloned = JSON.parse(JSON.stringify(action));
            const all = [];
            const collect = (act) => {
                if (!act || typeof act !== 'object') return;
                all.push(act);
                if (isConditionalAction(act)) {
                    (act.then || []).forEach(collect);
                    (act.else || []).forEach(collect);
                } else if (isRepeatAction(act)) {
                    (act.do || []).forEach(collect);
                }
            };
            collect(cloned);

            const baseId = Date.now();
            let idCounter = 0;
            const uuidMap = new Map(); // old -> new
            const usedLinkLabels = new Set();

            const makeCopyLinkLabel = (label) => {
                const cleaned = String(label || '').replace(/[^\w.-]/g, '').trim() || 'copy';
                let candidate = `${cleaned}_copy`;
                let suffix = 2;
                while (usedLinkLabels.has(candidate)) {
                    candidate = `${cleaned}_copy${suffix++}`;
                }
                usedLinkLabels.add(candidate);
                return candidate;
            };

            // First pass: assign new IDs + control group IDs, and build UUID remap for internal outputs.
            all.forEach((act) => {
                act.id = baseId + (idCounter++) + Math.floor(Math.random() * 1000);
                if (!act.params) act.params = {};
                if (isControlAction(act)) {
                    act.params.GroupingIdentifier = genUUID();
                }

                const oldUuidRaw =
                    (typeof act.params.UUID === 'string' && act.params.UUID.trim()) ? act.params.UUID.trim()
                        : (typeof act.params.OutputUUID === 'string' && act.params.OutputUUID.trim()) ? act.params.OutputUUID.trim()
                            : null;
                if (!oldUuidRaw || uuidMap.has(oldUuidRaw)) return;

                if (oldUuidRaw.toLowerCase().startsWith('!link:')) {
                    const oldLabel = oldUuidRaw.slice(6).trim();
                    const newLabel = makeCopyLinkLabel(oldLabel);
                    uuidMap.set(oldUuidRaw, `!link:${newLabel}`);
                } else {
                    uuidMap.set(oldUuidRaw, genUUID());
                }
            });

            const remapStringValue = (value) => {
                const str = String(value);
                // Replace embedded tokens first (for mixed strings).
                const withTokens = str.replace(/!link:[^\s]+/gi, (token) => uuidMap.get(token.trim()) || token);
                const trimmed = withTokens.trim();
                return uuidMap.get(trimmed) || withTokens;
            };

            const remapAny = (value) => {
                if (typeof value === 'string') return remapStringValue(value);
                if (Array.isArray(value)) return value.map(remapAny);
                if (value && typeof value === 'object') {
                    Object.keys(value).forEach((k) => {
                        value[k] = remapAny(value[k]);
                    });
                    return value;
                }
                return value;
            };

            // Second pass: apply new UUIDs to producers, and update internal references.
            all.forEach((act) => {
                if (!act.params) act.params = {};
                // Migrate any legacy field first
                if (act.params.ProvidedOutputUUID && !act.params.UUID) {
                    act.params.UUID = act.params.ProvidedOutputUUID;
                }
                if (act.params.ProvidedOutputUUID) delete act.params.ProvidedOutputUUID;

                const uuidBefore =
                    (typeof act.params.UUID === 'string' && act.params.UUID.trim()) ? act.params.UUID.trim()
                        : (typeof act.params.OutputUUID === 'string' && act.params.OutputUUID.trim()) ? act.params.OutputUUID.trim()
                            : '';
                const remappedUuid = uuidBefore ? (uuidMap.get(uuidBefore) || uuidBefore) : genUUID();
                act.params.UUID = remappedUuid;
                if (typeof act.params.OutputUUID === 'string' && act.params.OutputUUID.trim() === uuidBefore) {
                    act.params.OutputUUID = remappedUuid;
                }

                // Update any internal param references to duplicated actions
                act.params = remapAny(act.params);
            });
            return cloned;
        }

        function resolveConditionOptions(action, rawValue) {
            const params = action?.params || {};
            const optionsSource =
                params.ConditionOptions ||
                params.WFConditionOptions ||
                (rawValue && String(rawValue).includes('/') ? rawValue : null) ||
                (params.Condition && String(params.Condition).includes('/') ? params.Condition : null) ||
                (params.WFCondition && String(params.WFCondition).includes('/') ? params.WFCondition : null) ||
                DEFAULT_CONDITION_OPTIONS;

            const optionsString = String(optionsSource || DEFAULT_CONDITION_OPTIONS);
            const options = optionsString.split('/').map(o => o.trim()).filter(o => o);

            let selected =
                params.ConditionValue ||
                params.WFConditionValue ||
                (!rawValue || String(rawValue).includes('/') ? null : rawValue) ||
                (params.Condition && !String(params.Condition).includes('/') ? params.Condition : null) ||
                (params.WFCondition && !String(params.WFCondition).includes('/') ? params.WFCondition : null);

            if (!selected) selected = options[0] || 'Is';
            if (!options.includes(selected) && options.length > 0) selected = options[0];

            return { optionsString, options, selected };
        }

        function getConditionOptionsById(actionId, rawValue) {
            const loc = findActionLocation(actionId);
            return resolveConditionOptions(loc?.action, rawValue);
        }

        function isUnaryCondition(label = '') {
            const val = String(label).toLowerCase();
            return val === 'has any value' || val === 'does not have any value';
        }

        function flattenActions(actions = currentActions, result = []) {
            if (!Array.isArray(actions)) return result;
            actions.forEach(action => {
                result.push(action);
                if (isConditionalAction(action)) {
                    flattenActions(action.then || [], result);
                    flattenActions(action.else || [], result);
                } else if (isRepeatAction(action)) {
                    flattenActions(action.do || [], result);
                }
            });
            return result;
        }

        function buildParamPlaceholder(paramKey) {
            return `{{${String(paramKey || 'VALUE').toUpperCase()}}}`;
        }

        function getActionOutputInfo(action) {
            if (!action?.params) return null;
            const outputUUID = action.params.UUID;
            if (!outputUUID) return null;
            const rawUUID = String(outputUUID).trim();
            const rawNameCandidate =
                (action.params.CustomOutputNameEnabled && typeof action.params.CustomOutputName === 'string' && action.params.CustomOutputName.trim())
                    ? action.params.CustomOutputName.trim()
                    : (typeof action.params.OutputName === 'string' && action.params.OutputName.trim())
                        ? action.params.OutputName.trim()
                        : (rawUUID.toLowerCase().startsWith('!link:') ? rawUUID.slice(6).trim() : '')
                            || action.title || action.action || 'Action Output';

            const outputName = String(rawNameCandidate || '').trim() || 'Action Output';
            return { outputUUID: rawUUID, outputName };
        }

        function collectAvailableOutputs(actions = currentActions, set = new Set()) {
            if (!Array.isArray(actions)) return set;
            actions.forEach(action => {
                const info = getActionOutputInfo(action);
                if (info) set.add(info.outputUUID);
                if (isConditionalAction(action)) {
                    collectAvailableOutputs(action.then || [], set);
                    collectAvailableOutputs(action.else || [], set);
                } else if (isRepeatAction(action)) {
                    collectAvailableOutputs(action.do || [], set);
                }
            });
            return set;
        }

	        function pruneMissingOutputLinks() {
	            currentActions = ensureActionUUIDs(currentActions);
	            const flat = flattenActions(currentActions, []);
	            const actionIndexById = new Map();
	            const outputIndexByUuid = new Map();
	            flat.forEach((action, idx) => {
	                if (action?.id != null) actionIndexById.set(action.id, idx);
	                const info = getActionOutputInfo(action);
	                if (info?.outputUUID) {
	                    const key = String(info.outputUUID);
	                    if (!outputIndexByUuid.has(key)) outputIndexByUuid.set(key, idx);
	                }
	            });
	            const validOutputs = new Set(outputIndexByUuid.keys());
	            let mutated = false;
	            const scrubAction = (action) => {
	                if (!action?.params) return;
	                const currentIndex = actionIndexById.get(action.id);
	                Object.entries(action.params).forEach(([key, value]) => {
	                    if (value && typeof value === 'object') {
	                        const linkedUuid = value?.Value?.OutputUUID || value?.OutputUUID || '';
	                        const linkedKey = linkedUuid ? String(linkedUuid) : '';
	                        const sourceIndex = linkedKey ? outputIndexByUuid.get(linkedKey) : undefined;
	                        if (
	                            linkedKey &&
	                            (!validOutputs.has(linkedKey) ||
	                                (typeof currentIndex === 'number' && typeof sourceIndex === 'number' && sourceIndex >= currentIndex))
	                        ) {
	                            action.params[key] = buildParamPlaceholder(key);
	                            mutated = true;
	                        }
	                    }
	                });
	                if (isConditionalAction(action)) {
                    (action.then || []).forEach(scrubAction);
                    (action.else || []).forEach(scrubAction);
                } else if (isRepeatAction(action)) {
                    (action.do || []).forEach(scrubAction);
                }
            };
            (currentActions || []).forEach(scrubAction);
            if (mutated && currentProject) {
                currentProject.actions = currentActions;
                saveProjects();
            }
        }

        function getActionUUID(action) {
            if (!action.params) action.params = {};
            if (!action.params.GroupingIdentifier) action.params.GroupingIdentifier = genUUID();
            return action.params.GroupingIdentifier;
        }

        function isConditionalAction(action) {
            const id = (action.action || action.title || '').toLowerCase();
            return id.includes('conditional') || id === 'if' || id === 'otherwise' || id === 'endif';
        }

        function isRepeatAction(action) {
            const id = (action.action || action.title || '').toLowerCase();
            return id.includes('repeat') || id === 'repeatwitheach' || id === 'repeatwith each';
        }

        function isControlAction(action) {
            return isConditionalAction(action) || isRepeatAction(action);
        }

        function deleteProject(id) {
            if (event) event.stopPropagation();
            showDeleteModal('project', id);
        }

        // ============ Chat ============
        async function handleSend() {
            if (isGenerating) return;
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            if (!text) return;

            addMessageToUI(text, 'user');
            input.value = '';
            input.style.height = 'auto';

            if (currentProject) {
                currentProject.history.push({ role: 'user', content: text });
                saveProjects();
            }

            await callGenerateAPI(text);
        }

        function addMessageToUI(text, role) {
            const container = document.getElementById('messages');
            const div = document.createElement('div');
            div.className = `message ${role}`;
            const avatar = role === 'user'
                ? '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>'
                : 'F';
            div.innerHTML = `<div class="message-avatar">${avatar}</div><div class="message-bubble">${formatMessage(text)}</div>`;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function formatMessage(text) {
            return escapeHtml(text)
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function showTypingIndicator() {
            const container = document.getElementById('messages');
            const div = document.createElement('div');
            div.className = 'message assistant';
            div.id = 'typing-indicator';
            div.innerHTML = `<div class="message-avatar">F</div><div class="message-bubble"><div class="typing-indicator"><span></span><span></span><span></span></div></div>`;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function removeTypingIndicator() {
            document.getElementById('typing-indicator')?.remove();
        }

        function updateMarkdownPreview() {
            const preview = document.getElementById('markdown-preview');
            if (preview) {
                preview.style.display = 'none';
                preview.innerHTML = '';
            }
        }

	        // ============ AI API ============
	        function buildProgramPreviewActions(actions = currentActions) {
	            if (!Array.isArray(actions)) return [];
	            return actions.map(a => {
	                const entry = { action: a.action || a.title || 'Unknown', params: a.params || {} };
	                if (Array.isArray(a.then)) entry.then = buildProgramPreviewActions(a.then);
	                if (Array.isArray(a.else)) entry.else = buildProgramPreviewActions(a.else);
	                if (Array.isArray(a.do)) entry.do = buildProgramPreviewActions(a.do);
	                return entry;
	            });
	        }

	        function getCurrentProgramPreviewText() {
	            currentActions = ensureActionUUIDs(currentActions);
	            const hasActions = Array.isArray(currentActions) && currentActions.length > 0;
	            if (!hasActions) return '';
	            const programObj = {
	                name: currentProject?.name || 'My Shortcut',
	                actions: buildProgramPreviewActions(currentActions)
	            };
	            return JSON.stringify(programObj, null, 2);
	        }

	        async function callGenerateAPI(userPrompt) {
	            isGenerating = true;
	            const isDiscussionMode = chatMode === 'discussion';
	            if (!isDiscussionMode) showPipelineOrbs();
	            showTypingIndicator();

	            try {
	                const plan = (localStorage.getItem('flux_plan') || 'free') === 'paid' ? 'paid' : 'free';
	                const model = 'openai/gpt-oss-120b:free';
                console.log(`[Flux] Using model: ${model} (plan: ${plan})`);

	                const forceInstruction = forcedActions.length
	                    ? `You MUST include these actions in the next response and any generated shortcut: ${forcedActions.map(f => f.action).join(', ')}.`
	                    : '';

	                const userTurns = (currentProject?.history || []).filter(m => m.role === 'user');
	                const isFollowUp = userTurns.length > 1;
		                const mode = isDiscussionMode ? 'clarify' : (isFollowUp ? 'update' : 'plan');
		                const basePrompt = userTurns[0]?.content || userPrompt;
		                let programText = getCurrentProgramPreviewText();
		                const recentHistory = currentProject?.history?.slice(-10) || [];
		                const context = {
		                    basePrompt,
		                    programText,
	                    history: recentHistory
	                };
	                const body = {
	                    name: currentProject.name,
	                    prompt: userPrompt,
	                    followUp: isFollowUp,
	                    mode,
	                    context,
	                    history: recentHistory,
	                    model,
	                    plan,
	                    forcedActions,
	                    forceInstruction,
	                    style: 'concise'
	                };

	                const response = await fetch(`${API_BASE}/generate`, {
	                    method: 'POST',
	                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (!response.ok || !response.body) {
                    const errText = await response.text().catch(() => '');
                    throw new Error(`Generation failed (${response.status}) ${errText.slice(0, 120)}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let finalData = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (!line.trim() || !line.trim().startsWith('{')) continue;
                        try {
                            const packet = JSON.parse(line);
                            handleStreamPacket(packet);
                            if (packet.type === 'final' || packet.type === 'error') {
                                finalData = packet;
                            }
                        } catch (e) { console.warn('Parse error:', e); }
                    }
                }

                removeTypingIndicator();

                if (finalData) {
                    handleFinalResponse(finalData);
                }
                removePipelineOrbs();
            } catch (err) {
                console.error('API Error:', err);
                removeTypingIndicator();
                removePipelineOrbs();
                addMessageToUI('‚ö†Ô∏è Failed to connect to the AI service. Please try again.', 'assistant');
            }

            isGenerating = false;
        }

        function handleStreamPacket(packet) {
            if (packet.type === 'progress') {
                updatePipelineProgress(packet.step, packet.status, packet.hint);
            }
        }

        function updatePipelineStep(step, status) {
            const stepEl = document.getElementById(`step-${step}`);
            if (!stepEl) return;
            stepEl.classList.remove('active', 'completed');
            if (status === 'started') stepEl.classList.add('active');
            else if (status === 'completed') stepEl.classList.add('completed');
        }

	        function resetPipelineSteps() {
	            clearPipelinePendingStart();
	            currentPipelineStep = null;
	            if (pipelineStepCompleteTimers && typeof pipelineStepCompleteTimers.forEach === 'function') {
	                pipelineStepCompleteTimers.forEach((t) => { try { clearTimeout(t); } catch (e) { } });
	                pipelineStepCompleteTimers.clear();
	            }
	            pipelineStepStartedAt?.clear?.();

	            PIPELINE_STEPS.forEach(({ id }) => {
	                const el = document.getElementById(`step-${id}`);
	                if (el) el.classList.remove('active', 'completed');
	                const orb = document.getElementById(`orb-${id}`);
	                orb?.classList.remove('active', 'completed');
	            });
	            const hintEl = document.getElementById('pipeline-orbs-hint');
	            if (hintEl) hintEl.textContent = getDefaultHint('plan', 'active');
	        }

        function updatePipelineProgress(step, status, hint = '') {
            const order = PIPELINE_STEPS.map(s => s.id);
            // Map backend steps to frontend steps
            const stepMap = {
                'assess': 'plan',
                'search': 'catalog',
                'build': 'build',
                'summarize': 'summarize'
            };
            const frontendStep = stepMap[step] || step;
            const idx = order.indexOf(frontendStep);
            const now = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();

            if (status === 'started') {
                const applyStart = () => {
                    const startNow = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();
                    clearPipelinePendingStart();
                    currentPipelineStep = frontendStep;
                    clearPipelineStepTimer(frontendStep);
                    pipelineStepStartedAt.set(frontendStep, startNow);
                    if (idx > 0) {
                        for (let i = 0; i < idx; i++) {
                            clearPipelineStepTimer(order[i]);
                            updatePipelineOrb(order[i], 'completed');
                        }
                    }
                    updatePipelineOrb(frontendStep, 'started', hint);
                };

                const prevStep = idx > 0 ? order[idx - 1] : null;
                const prevStartedAt = prevStep ? pipelineStepStartedAt.get(prevStep) : null;
                const prevElapsed = (prevStep && typeof prevStartedAt === 'number') ? (now - prevStartedAt) : null;
                const delayMs = (prevStep && prevStep === currentPipelineStep && prevElapsed != null && prevElapsed < MIN_PIPELINE_ACTIVE_MS)
                    ? (MIN_PIPELINE_ACTIVE_MS - prevElapsed)
                    : 0;

                if (delayMs > 0) {
                    clearPipelinePendingStart();
                    pipelinePendingStartTimer = setTimeout(applyStart, delayMs);
                    return;
                }

                applyStart();
                return;
            }

            if (status === 'completed') {
                const startedAt = pipelineStepStartedAt.get(frontendStep);
                const elapsed = typeof startedAt === 'number' ? (now - startedAt) : null;
                const remaining = (elapsed != null && elapsed < MIN_PIPELINE_ACTIVE_MS)
                    ? (MIN_PIPELINE_ACTIVE_MS - elapsed)
                    : 0;

                clearPipelineStepTimer(frontendStep);

                const applyCompletion = () => {
                    if (frontendStep === currentPipelineStep) updatePipelineOrb(frontendStep, 'completed', hint);
                    else updatePipelineOrb(frontendStep, 'completed');
                };

                if (remaining > 0) {
                    pipelineStepCompleteTimers.set(frontendStep, setTimeout(() => {
                        pipelineStepCompleteTimers.delete(frontendStep);
                        applyCompletion();
                    }, remaining));
                } else {
                    applyCompletion();
                }
                return;
            }

            updatePipelineOrb(frontendStep, status, hint);
        }

	        function handleFinalResponse(data) {
	            if (!data.ok) {
	                addMessageToUI(`‚ö†Ô∏è ${data.message || 'An error occurred'}`, 'assistant');
	                return;
	            }
	            const isDiscussionMode = chatMode === 'discussion';
	            const nextName = typeof data.finalName === 'string' ? data.finalName.trim() : '';
	            const willApplyProgram = !!data.program && !isDiscussionMode;
	            const willApplyName = !!(nextName && currentProject && !isDiscussionMode && nextName !== currentProject.name);
	            if (willApplyProgram || willApplyName) {
	                pushUndoState();
	            }
	            PIPELINE_STEPS.forEach(({ id }) => updatePipelineOrb(id, 'completed'));

	            // Update project name from AI
	            if (willApplyName) {
	                currentProject.name = nextName;
	                document.getElementById('project-name-input').value = nextName;
	            }

	            // Store program object
	            if (willApplyProgram) {
	                currentProgramObj = data.program;
	                if (currentProject) currentProject.programObj = currentProgramObj;

	                // Extract actions from program
	                if (Array.isArray(data.program.actions)) {
                    currentActions = data.program.actions.map((act, i) => {
                        const actionObj = {
                            id: Date.now() + i,
                            action: act.action || 'Unknown',
                            title: act.action || 'Action',
                            params: act.params || {}
                        };
                        // Preserve nested structure (then/else/do arrays) if present
                        if (Array.isArray(act.then)) actionObj.then = act.then;
                        if (Array.isArray(act.else)) actionObj.else = act.else;
                        if (Array.isArray(act.do)) actionObj.do = act.do;
                        return actionObj;
                    });
	                    currentActions = ensureActionUUIDs(currentActions);
	                    if (currentProject) currentProject.actions = currentActions;
	                }
	            }

            // Add AI response to chat
            if (data.answer) {
                addMessageToUI(data.answer, 'assistant');
                if (currentProject) {
                    currentProject.history.push({ role: 'assistant', content: data.answer });
                }
            }

	            saveProjects();
	            if (willApplyProgram) {
	                // Animate all actions from AI response
	                renderActions(true);
	            }
	            updateUndoRedoButtons();
	        }

        // ============ Actions Preview ============
        function renderActions(animateIds = null) {
            const container = document.getElementById('actions-container');
            const emptyState = document.getElementById('empty-state');
            pruneMissingOutputLinks();
            currentActions = ensureActionUUIDs(currentActions);

            if (currentActions.length === 0) {
                container.classList.add('hidden');
                emptyState.classList.remove('hidden');
                return;
            }

            emptyState.classList.add('hidden');
            container.classList.remove('hidden');
            container.innerHTML = '';

	            const tree = buildActionTree(currentActions);
	            renderNodeList(tree, container, animateIds);
	            initActionReordering();

	        }

        function buildActionTree(actions) {
            const root = [];
            const stack = [{ id: null, target: root, node: null }];

            actions.forEach(action => {
                // Nested JSON format (already has then/else/do arrays)
                if (isConditionalAction(action) && (Array.isArray(action.then) || Array.isArray(action.else))) {
                    const node = {
                        type: 'if',
                        action,
                        children: buildActionTree(action.then || []),
                        elseChildren: buildActionTree(action.else || [])
                    };
                    stack[stack.length - 1].target.push(node);
                    return;
                }

                if (isRepeatAction(action) && Array.isArray(action.do)) {
                    const node = { type: 'repeat', action, children: buildActionTree(action.do || []) };
                    stack[stack.length - 1].target.push(node);
                    return;
                }

                // Flat list format using WFControlFlowMode
                if (isConditionalAction(action)) {
                    const mode = Number(action.params?.WFControlFlowMode ?? 0);
                    const gid = action.params?.GroupingIdentifier || getActionUUID(action);
                    if (mode === 0) {
                        const node = { type: 'if', action, children: [], elseChildren: [] };
                        stack[stack.length - 1].target.push(node);
                        stack.push({ id: gid, target: node.children, node, inElse: false });
                    } else if (mode === 1) {
                        const idx = [...stack].reverse().findIndex(s => s.id === gid);
                        if (idx !== -1) {
                            const realIdx = stack.length - 1 - idx;
                            const ref = stack[realIdx];
                            ref.target = ref.node.elseChildren;
                        }
                    } else if (mode === 2) {
                        if (stack.length > 1 && stack[stack.length - 1].id === gid) {
                            stack.pop();
                        } else {
                            const pos = stack.findIndex(s => s.id === gid);
                            if (pos > 0) stack.splice(pos, stack.length - pos);
                        }
                    }
                    return;
                }

                if (isRepeatAction(action)) {
                    const node = { type: 'repeat', action, children: [] };
                    stack[stack.length - 1].target.push(node);
                    stack.push({ id: action.params?.GroupingIdentifier || getActionUUID(action), target: node.children, node });
                    return;
                }

                stack[stack.length - 1].target.push({ type: 'action', action });
            });

            return root;
        }

        function renderNodeList(nodes, container, animateIds, depth = 0, parentMeta = { parentActionId: null, parentSection: 'root' }) {
	            nodes.forEach((node, index) => {
	                if (node.type === 'if') {
	                    const block = document.createElement('div');
	                    block.className = 'if-block';
	                    block.dataset.actionId = node.action.id;
	                    block.dataset.id = node.action.id;
	                    block.dataset.parentId = parentMeta?.parentActionId || '';
	                    block.dataset.parentSection = parentMeta?.parentSection || 'root';
	                    
	                    // Get IF condition parameters
	                    const input = node.action.params?.Input || node.action.params?.WFInput || '{{VARIABLE}}';
	                    const compareTo = node.action.params?.CompareTo || node.action.params?.WFConditionalActionString || '{{STRING}}';
	                    const conditionMeta = resolveConditionOptions(node.action, node.action.params?.Condition || node.action.params?.WFCondition || DEFAULT_CONDITION_OPTIONS);
                    const unaryCondition = isUnaryCondition(conditionMeta.selected);
                    const conditionInputHtml = editMode
                        ? getInputForType(node.action.id, 'Condition', conditionMeta.optionsString, false)
                        : `<span class="condition-value">${escapeHtml(conditionMeta.selected)}</span>`;
                    const inputInputHtml = editMode ? getInputForType(node.action.id, 'Input', input, false) : `<span class="condition-value">${formatLinkedValue(input)}</span>`;
                    const compareToInputHtml = unaryCondition ? '' : (editMode ? getInputForType(node.action.id, 'CompareTo', compareTo, false) : `<span class="condition-value">${formatLinkedValue(compareTo)}</span>`);
                    
                    const actionsHtml = editMode ? `
                        <div class="control-actions">
                            <button class="node-action-btn" onclick="duplicateAction(${node.action.id})" title="Duplicate"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                            <button class="node-action-btn delete" onclick="deleteAction(${node.action.id})" title="Delete"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                        </div>
                    ` : '';
                    
                    const thenEmpty = (!node.children || node.children.length === 0);
                    const elseEmpty = (!node.elseChildren || node.elseChildren.length === 0);
                    const thenEmptyHint = thenEmpty && editMode ? '<div class="empty-section-hint">place actions here</div>' : '';
                    const elseEmptyHint = elseEmpty && editMode ? '<div class="empty-section-hint">place actions here</div>' : '';
	                    const dropZoneClass = editMode ? 'drop-zone' : '';
	                    const dragHandle = editMode ? '<div class="node-drag-handle" data-reorder-handle="true" title="Drag to reorder" style="touch-action:none; user-select:none;"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><circle cx="9" cy="6" r="2"></circle><circle cx="15" cy="6" r="2"></circle><circle cx="9" cy="12" r="2"></circle><circle cx="15" cy="12" r="2"></circle><circle cx="9" cy="18" r="2"></circle><circle cx="15" cy="18" r="2"></circle></svg></div>' : '';
	                    
	                    block.innerHTML = `
	                        <div class="if-header">
	                            ${dragHandle}
	                            <div class="if-condition-line">
	                                <span class="if-label">If</span>
	                                ${inputInputHtml}
	                                ${conditionInputHtml}
                                ${compareToInputHtml}
                                <span class="if-then-label">Then</span>
                            </div>
                            ${actionsHtml}
                        </div>
                        <div class="if-then ${thenEmpty ? 'empty-section' : ''} ${dropZoneClass}" data-drop-zone="if-then" data-action-id="${node.action.id}">
                            ${thenEmpty ? '' : '<div class="control-section-content"></div>'}
                            ${thenEmptyHint}
                        </div>
                        <div class="if-else-divider">Otherwise</div>
                        <div class="if-else ${elseEmpty ? 'empty-section' : ''} ${dropZoneClass}" data-drop-zone="if-else" data-action-id="${node.action.id}">
                            ${elseEmpty ? '' : '<div class="control-section-content"></div>'}
                            ${elseEmptyHint}
                        </div>
                        <div class="if-end">End</div>
                    `;
                    if (node.children && node.children.length > 0) {
                        const thenContainer = block.querySelector('.if-then .control-section-content');
                        if (thenContainer) {
                            renderNodeList(node.children, thenContainer, animateIds, depth + 1, { parentActionId: node.action.id, parentSection: 'then' });
                        }
                    }
                    if (node.elseChildren && node.elseChildren.length > 0) {
                        const elseContainer = block.querySelector('.if-else .control-section-content');
                        if (elseContainer) {
                            renderNodeList(node.elseChildren, elseContainer, animateIds, depth + 1, { parentActionId: node.action.id, parentSection: 'else' });
                        }
                    }
                    container.appendChild(block);
	                } else if (node.type === 'repeat') {
	                    const block = document.createElement('div');
	                    block.className = 'repeat-block';
	                    block.dataset.actionId = node.action.id;
	                    block.dataset.id = node.action.id;
	                    block.dataset.parentId = parentMeta?.parentActionId || '';
	                    block.dataset.parentSection = parentMeta?.parentSection || 'root';
	                    
	                    // Get REPEAT parameters - check if it's RepeatWithEach
	                    const actionName = (node.action.action || '').toLowerCase();
	                    const isRepeatWithEach = actionName.includes('witheach') || actionName.includes('with each');
                    const repeatCount = node.action.params?.Count || node.action.params?.WFRepeatCount || '';
                    const repeatItems = node.action.params?.Items || node.action.params?.RepeatItemVariableName || node.action.params?.WFRepeatItemVariableName || '';
                    
                    const actionsHtml = editMode ? `
                        <div class="control-actions">
                            <button class="node-action-btn" onclick="duplicateAction(${node.action.id})" title="Duplicate"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                            <button class="node-action-btn delete" onclick="deleteAction(${node.action.id})" title="Delete"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                        </div>
                    ` : '';
                    
	                    const emptyBodyClass = (!node.children || node.children.length === 0) ? 'empty-section' : '';
	                    const emptyHint = (!node.children || node.children.length === 0) && editMode ? '<div class="empty-section-hint">place actions here</div>' : '';
	                    const dropZoneClass = editMode ? 'drop-zone' : '';
	                    const dragHandle = editMode ? '<div class="node-drag-handle" data-reorder-handle="true" title="Drag to reorder" style="touch-action:none; user-select:none;"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><circle cx="9" cy="6" r="2"></circle><circle cx="15" cy="6" r="2"></circle><circle cx="9" cy="12" r="2"></circle><circle cx="15" cy="12" r="2"></circle><circle cx="9" cy="18" r="2"></circle><circle cx="15" cy="18" r="2"></circle></svg></div>' : '';
                    
                    let repeatHeaderHtml = '';
                    if (isRepeatWithEach || repeatItems) {
                        const itemsInputHtml = editMode ? getInputForType(node.action.id, 'Items', repeatItems || '{{VARIABLE}}', false) : `<span class="repeat-value">${formatLinkedValue(repeatItems || '')}</span>`;
                        repeatHeaderHtml = `
                            <div class="repeat-condition-line">
                                <span class="repeat-label">Repeat with each item in</span>
                                ${itemsInputHtml}
                            </div>
                        `;
                    } else if (repeatCount) {
                        const countInputHtml = editMode ? getInputForType(node.action.id, 'Count', repeatCount, false) : `<span class="repeat-value">${formatLinkedValue(repeatCount)}</span>`;
                        repeatHeaderHtml = `
                            <div class="repeat-condition-line">
                                <span class="repeat-label">Repeat</span>
                                ${countInputHtml}
                                <span class="repeat-text">times</span>
                            </div>
                        `;
                    } else {
                        const countInputHtml = editMode ? getInputForType(node.action.id, 'Count', '{{NUMBER}}', false) : '<span class="repeat-value">(configure)</span>';
                        repeatHeaderHtml = `
                            <div class="repeat-condition-line">
                                <span class="repeat-label">Repeat</span>
                                ${countInputHtml}
                                <span class="repeat-text">times</span>
                            </div>
                        `;
                    }
                    
	                    block.innerHTML = `
	                        <div class="repeat-header">
	                            ${dragHandle}
	                            ${repeatHeaderHtml}
	                            ${actionsHtml}
	                        </div>
                        <div class="repeat-body ${emptyBodyClass} ${dropZoneClass}" data-drop-zone="repeat" data-action-id="${node.action.id}">
                            ${emptyBodyClass ? '' : '<div class="control-section-content"></div>'}
                            ${emptyHint}
                        </div>
                        <div class="repeat-end">End</div>
                    `;
	                    block.dataset.id = node.action.id;
	                    block.dataset.type = node.action.action;
                    if (node.children && node.children.length > 0) {
                        const body = block.querySelector('.repeat-body .control-section-content');
                        if (body) {
                            renderNodeList(node.children, body, animateIds, depth + 1, { parentActionId: node.action.id, parentSection: 'do' });
                        }
                    }
                    container.appendChild(block);
                } else {
                    const shouldAnimate = animateIds === true || (Array.isArray(animateIds) && animateIds.includes(node.action.id));
                    const actionNode = createActionNode(node.action, index, shouldAnimate, parentMeta);
                    container.appendChild(actionNode);
                }
            });
        }

	        function createActionNode(action, index, shouldAnimate = false, parentMeta = { parentActionId: null, parentSection: 'root' }) {
	            const node = document.createElement('div');
	            node.className = 'action-node';
	            if (shouldAnimate && animationsEnabled) {
	                node.classList.add('settling');
	                node.style.animationDelay = `${index * 0.1}s`;
	            }
	            node.dataset.id = action.id;
	            node.dataset.index = index;
	            node.dataset.type = action.action;
	            node.dataset.parentId = parentMeta?.parentActionId || '';
	            node.dataset.parentSection = parentMeta?.parentSection || 'root';

	            // Get output information
	            const outputInfo = getActionOutputInfo(action);
	            const outputUUID = outputInfo?.outputUUID || null;
	            const outputDisplay = outputInfo ? humanizeOutputName(outputInfo.outputName) : '';
	            if (outputUUID) node.classList.add('has-output');
	            const outputHtml = outputUUID ? `<div class="node-output" data-output-uuid="${escapeHtml(String(outputUUID))}" title="Output: ${escapeHtml(outputDisplay)}">
	                <span class="output-label">${escapeHtml(outputDisplay)}</span>
	            </div>` : '';

            let paramsHtml = '';
            // Show params if in edit mode OR if they have a value (not empty/default)
            if (action.params && Object.keys(action.params).length > 0 && !isControlAction(action)) {
                let hasVisibleParams = false;
                let innerHtml = '<div class="node-params">';
                for (const [key, value] of Object.entries(action.params)) {
                    // Skip UUID/OutputUUID/GroupingIdentifier as they're internal
                    const lowerKey = String(key).toLowerCase();
                    if (lowerKey === 'uuid' || lowerKey === 'outputuuid' || lowerKey === 'groupingidentifier' || lowerKey === 'providedoutputuuid') {
                        continue;
                    }
                    // Always show params in edit mode, or if they have a non-placeholder value in view mode
                    const strVal = String(value);
                    const isPlaceholder = strVal.startsWith('{{') && strVal.endsWith('}}');
                    // Show if edit mode OR (has value AND not a placeholder)
                    if (editMode || (strVal && !isPlaceholder)) {
                        hasVisibleParams = true;
                        const inputHtml = getInputForType(action.id, key, value, !editMode);
                        innerHtml += `
                            <div class="node-param">
                                <span class="param-label">${escapeHtml(key)}</span>
                                ${inputHtml}
                            </div>
                        `;
                    }
                }
                innerHtml += '</div>';
                if (hasVisibleParams) {
                    paramsHtml = innerHtml;
                }
            }

            const actionsHtml = editMode ? `
                <div class="node-actions">
                    <button class="node-action-btn" onclick="duplicateAction(${action.id})" title="Duplicate"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                    <button class="node-action-btn delete" onclick="deleteAction(${action.id})" title="Delete"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                </div>
            ` : '';

	            const dragHandle = editMode ? '<div class="node-drag-handle" data-reorder-handle="true" title="Drag to reorder" style="touch-action:none; user-select:none;"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><circle cx="9" cy="6" r="2"></circle><circle cx="15" cy="6" r="2"></circle><circle cx="9" cy="12" r="2"></circle><circle cx="15" cy="12" r="2"></circle><circle cx="9" cy="18" r="2"></circle><circle cx="15" cy="18" r="2"></circle></svg></div>' : '';

            node.innerHTML = `
                ${dragHandle}
                <div class="node-icon">${getActionIcon(action.action)}</div>
                <div class="node-content">
                    <div class="node-header">
                        <span class="node-title">${escapeHtml(action.title || action.action)}</span>
                        ${actionsHtml}
                    </div>
                    ${outputHtml}
                    ${paramsHtml}
                </div>
            `;
            return node;
        }

        function getInputForType(actionId, key, value, readonly = false) {
            if (String(key).toLowerCase() === 'uuid') {
                return '';
            }
            if (key === 'Condition' || key === 'WFCondition') {
                const { optionsString, options, selected } = getConditionOptionsById(actionId, value);
                const selectedValue = options.includes(selected) ? selected : (options[0] || selected);
                const optionsHtml = options.map(opt => `<option value="${escapeHtml(opt)}" ${opt === selectedValue ? 'selected' : ''}>${escapeHtml(opt)}</option>`).join('');
                const fullOptionsString = optionsString || DEFAULT_CONDITION_OPTIONS;
                return `<select class="param-value param-select" data-action-id="${actionId}" data-param="${escapeHtml(key)}" data-full-options="${escapeHtml(fullOptionsString)}" ${readonly ? 'disabled' : ''} onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.value)">${optionsHtml}</select>`;
            }
            const isObjectVal = value && typeof value === 'object' && !Array.isArray(value);
            if (isObjectVal) {
                const outputName = value?.Value?.OutputName || value?.OutputName || 'Linked Output';
                const outputUUID = value?.Value?.OutputUUID || value?.OutputUUID || '';
                const safeParam = escapeHtml(key).replace(/'/g, "\\'");
                const displayName = humanizeOutputName(outputName);
                return `<div class="linked-output" data-output-uuid="${escapeHtml(outputUUID)}" title="Linked from: ${escapeHtml(outputName)}">
                    <span class="linked-output-label">${escapeHtml(displayName)}</span>
                    ${!readonly ? `<button type="button" class="node-action-btn" onclick="clearLinkedParam(${actionId}, '${safeParam}')" title="Unlink">Unlink</button>` : ''}
                </div>`;
            }

            const strValue = String(value);
            const disabledAttr = readonly ? 'disabled' : '';
            
            // Check for !link: tokens first
            if (strValue.trim().startsWith('!link:')) {
                const linkLabel = strValue.replace(/^!link:/i, '').trim();
                const displayName = humanizeOutputName(linkLabel);
                const safeParam = escapeHtml(key).replace(/'/g, "\\'");
                return `<div class="linked-output" data-link-label="${escapeHtml(linkLabel)}" title="Linked from: ${escapeHtml(linkLabel)}">
                    <span class="linked-output-label">${escapeHtml(displayName)}</span>
                    ${!readonly ? `<button type="button" class="node-action-btn" onclick="clearLinkedParam(${actionId}, '${safeParam}')" title="Unlink">Unlink</button>` : ''}
                </div>`;
            }
            
            // Check for variables like {{Ask Each Time}} - show as blue box
            const variableMatch = strValue.match(/^\{\{([^}]+)\}\}$/);
            if (variableMatch) {
                const varName = variableMatch[1].trim();
                // Check if it's a standard placeholder (STRING, VARIABLE, NUMBER, etc.)
                const isStandardPlaceholder = /^(STRING|VARIABLE|NUMBER|INTEGER|DECIMAL|BOOLEAN)$/i.test(varName);
                if (!isStandardPlaceholder) {
                    // It's a named variable like "Ask Each Time" - show as blue box
                    if (readonly) {
                        return `<span class="linked-value-inline">${escapeHtml(varName)}</span>`;
                    } else {
                        // In edit mode, show as styled input that looks like blue box
                        const contextMenuAttr = 'oncontextmenu="showVariableMenu(event, this)"';
                        return `<input type="text" class="param-value param-variable-input" data-action-id="${actionId}" data-param="${escapeHtml(key)}" value="${escapeHtml(strValue)}" ${disabledAttr} onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.value)" ${contextMenuAttr} placeholder="Enter variable">`;
                    }
                }
            }
            
            // Check for placeholders like {{STRING}}, {{VARIABLE}}, {{NUMBER}}, etc.
            const placeholderMatch = strValue.match(/^\{\{(\w+)\}\}$/);
            if (placeholderMatch && !readonly) {
                const placeholderType = placeholderMatch[1].toLowerCase();
                if (placeholderType === 'number' || placeholderType === 'integer' || placeholderType === 'decimal') {
                    return `<input type="number" class="param-value param-number" data-action-id="${actionId}" data-param="${escapeHtml(key)}" placeholder="Enter number" onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.value)">`;
                } else if (placeholderType === 'boolean') {
                    return `<input type="checkbox" class="param-checkbox" data-action-id="${actionId}" data-param="${escapeHtml(key)}" onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.checked)">`;
                } else {
                    // Default to text input for STRING, VARIABLE, etc.
                    const contextMenuAttr = 'oncontextmenu="showVariableMenu(event, this)"';
                    return `<input type="text" class="param-value" data-action-id="${actionId}" data-param="${escapeHtml(key)}" placeholder="Enter ${placeholderType.toLowerCase()}" onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.value)" ${contextMenuAttr}>`;
                }
            }
            
            const lowerVal = strValue.toLowerCase();

            // Boolean detection
            if (lowerVal === 'true' || lowerVal === 'false' || strValue === '{{BOOLEAN}}') {
                const checked = lowerVal === 'true' ? 'checked' : '';
                return `<input type="checkbox" class="param-checkbox" data-action-id="${actionId}" data-param="${escapeHtml(key)}" ${checked} ${disabledAttr} onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.checked)">`;
            }

            // Number detection
            if (!isNaN(strValue) && strValue !== '' && !readonly) {
                return `<input type="number" class="param-value param-number" data-action-id="${actionId}" data-param="${escapeHtml(key)}" value="${escapeHtml(strValue)}" ${disabledAttr} onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.value)">`;
            }

	            // Option-style placeholders (e.g. "Small/Medium/Large" or "{{Small/Medium/Large}}")
	            if (!readonly) {
	                const braceOptionsMatch = strValue.match(/^\{\{([^}]+\/[^}]+)\}\}$/);
	                const rawOptions = braceOptionsMatch ? braceOptionsMatch[1] : strValue;
	                const trimmedOptions = String(rawOptions || '').trim();
	                const looksLikeUrl = trimmedOptions.includes('://');
	                const looksLikeDrivePath = /^[a-zA-Z]:/.test(trimmedOptions) && (trimmedOptions[2] === '/' || trimmedOptions[2] === '\\\\');
	                const looksLikePath = trimmedOptions.startsWith('/') || looksLikeDrivePath;
	                const hasLetters = /[a-zA-Z]/.test(trimmedOptions);
	                const options = trimmedOptions.split('/').map(o => o.trim()).filter(Boolean);
	                if (hasLetters && !looksLikeUrl && !looksLikePath && options.length >= 2) {
	                    const placeholderText = options.join('/');
	                    const contextMenuAttr = 'oncontextmenu="showVariableMenu(event, this)"';
	                    return `<input type="text" class="param-value param-option-placeholder" data-action-id="${actionId}" data-param="${escapeHtml(key)}" value="" placeholder="${escapeHtml(placeholderText)}" ${disabledAttr} onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.value)" ${contextMenuAttr}>`;
	                }
	            }

            // Check if this is a text field that can contain mixed content with links
            // (like LLMPrompt in Askllm which can have text mixed with !link: tokens)
            const canHaveMixedLinks = strValue.includes('!link:') && strValue.length > strValue.indexOf('!link:') + 6;
            
            if (canHaveMixedLinks && !readonly) {
                // Use textarea for mixed content fields
                const contextMenuAttr = 'oncontextmenu="showVariableMenu(event, this)"';
                return `<textarea class="param-value param-textarea" data-action-id="${actionId}" data-param="${escapeHtml(key)}" ${disabledAttr} onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.value)" ${contextMenuAttr} rows="3">${escapeHtml(strValue)}</textarea>`;
            } else if (canHaveMixedLinks && readonly) {
                // Display mixed content with proper formatting
                return `<div class="param-value param-mixed-content">${formatLinkedValue(strValue)}</div>`;
            }
            
            // Default text input
            const contextMenuAttr = readonly ? '' : 'oncontextmenu="showVariableMenu(event, this)"';
            return `<input type="text" class="param-value" data-action-id="${actionId}" data-param="${escapeHtml(key)}" value="${escapeHtml(strValue)}" ${disabledAttr} onchange="updateActionParam(${actionId}, '${escapeHtml(key)}', this.value)" ${contextMenuAttr}>`;
        }

        function humanizeOutputName(name) {
            if (!name) return 'Output';
            return String(name).replace(/^!link:/i, '').trim() || 'Output';
        }

        function formatLinkedValue(value) {
            if (!value) return '';
            const strVal = String(value);
            if (strVal.trim().startsWith('!link:')) {
                const linkLabel = strVal.replace(/^!link:/i, '').trim();
                return `<span class="linked-value-inline">${escapeHtml(humanizeOutputName(linkLabel))}</span>`;
            }
            // Check for variables like {{Ask Each Time}}, {{Clipboard}}, etc.
            const variableMatch = strVal.match(/^\{\{([^}]+)\}\}$/);
            if (variableMatch) {
                const varName = variableMatch[1].trim();
                return `<span class="linked-value-inline">${escapeHtml(varName)}</span>`;
            }
            // Check if value contains !link: tokens mixed with text
            if (strVal.includes('!link:')) {
                // Parse mixed content
                const parts = strVal.split(/(!link:[^\s]+)/gi);
                return parts.map(part => {
                    if (part.toLowerCase().startsWith('!link:')) {
                        const linkLabel = part.replace(/^!link:/i, '').trim();
                        return `<span class="linked-value-inline">${escapeHtml(humanizeOutputName(linkLabel))}</span>`;
                    }
                    // Also check for {{variable}} patterns in mixed content
                    const varMatch = part.match(/\{\{([^}]+)\}\}/g);
                    if (varMatch) {
                        let result = part;
                        varMatch.forEach(match => {
                            const varName = match.replace(/\{\{|\}\}/g, '').trim();
                            result = result.replace(match, `<span class="linked-value-inline">${escapeHtml(varName)}</span>`);
                        });
                        return result;
                    }
                    return escapeHtml(part);
                }).join('');
            }
            // Check for {{variable}} patterns in the string
            if (strVal.includes('{{') && strVal.includes('}}')) {
                return strVal.replace(/\{\{([^}]+)\}\}/g, (match, varName) => {
                    return `<span class="linked-value-inline">${escapeHtml(varName.trim())}</span>`;
                });
            }
            return escapeHtml(strVal);
        }

        function formatParamValue(value) {
            if (typeof value === 'string') {
                // Highlight variables like {{input}} or {{Clipboard}}
                return value.replace(/\{\{([^}]+)\}\}/g, '<span class="variable-tag">$1</span>');
            }
            return String(value);
        }

        function getActionIcon(actionType) {
            const icons = {
                'If': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>',
                'Repeat': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>',
                'Ask.ForInput': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>',
                'Notification': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>',
                'Openurl': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>',
                'Showresult': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"></rect><line x1="9" y1="9" x2="15" y2="9"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>',
                'Getclipboard': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>',
                'Text': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>',
                'Variable.Set': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line></svg>'
            };
            return icons[actionType] || '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"></rect></svg>';
        }

	        function updateActionParam(actionId, paramKey, value) {
	            const loc = findActionLocation(actionId);
	            const action = loc?.action;
	            if (!action) return;
	            if (!action.params) action.params = {};

	            if (paramKey === 'Condition' || paramKey === 'WFCondition') {
	                const prevValue = action.params.ConditionValue ?? action.params.WFConditionValue ?? action.params.Condition ?? action.params.WFCondition ?? '';
	                if (String(prevValue) !== String(value)) {
	                    pushUndoState();
	                }
	                const selectEl = document.querySelector(`select[data-action-id="${actionId}"][data-param="${paramKey}"], select[data-action-id="${actionId}"][data-param="Condition"]`);
	                const fullOptions = selectEl?.dataset.fullOptions || action.params.ConditionOptions || action.params.WFConditionOptions || DEFAULT_CONDITION_OPTIONS;
	                action.params.ConditionOptions = fullOptions;
	                action.params.WFConditionOptions = fullOptions;
	                action.params.ConditionValue = value;
	                action.params.WFConditionValue = value;
	                action.params.Condition = value;
	                action.params.WFCondition = value;
	            } else {
	                const prevValue = action.params[paramKey];
	                if (prevValue !== value) {
	                    pushUndoState();
	                }
	                action.params[paramKey] = value;
	            }
	            commitActionChanges();
	        }

        let deleteTargetId = null;
        let deleteTargetType = null; // 'action' or 'project'

        function showDeleteModal(type, id) {
            deleteTargetType = type;
            deleteTargetId = id;

            const titleEl = document.querySelector('#delete-modal h3');
            const textEl = document.querySelector('#delete-modal p');

            if (type === 'project') {
                titleEl.textContent = 'Delete Project?';
                textEl.textContent = 'Are you sure you want to delete this project? This cannot be undone.';
            } else {
                titleEl.textContent = 'Delete Action?';
                textEl.textContent = 'Are you sure you want to delete this action? This cannot be undone.';
            }

            document.getElementById('delete-modal').classList.add('active');
        }

        function closeDeleteModal() {
            document.getElementById('delete-modal').classList.remove('active');
            deleteTargetId = null;
            deleteTargetType = null;
        }

        function confirmDeleteAction() {
            if (!deleteTargetId) return;

            if (deleteTargetType === 'project') {
                projects = projects.filter(p => p.id !== deleteTargetId);
                saveProjects();
                if (currentProject && currentProject.id === deleteTargetId) {
                    currentProject = null;
                    currentActions = [];
                    showProjectsView();
                } else {
                    renderProjectsGrid();
                }
	            } else if (deleteTargetType === 'action') {
	                pushUndoState();
	                // Recursively collect all action IDs to delete (including nested ones)
	                const idsToDelete = new Set([deleteTargetId]);
                
                function collectNestedActionIds(action) {
                    if (isConditionalAction(action)) {
                        // Collect actions from then and else arrays
                        if (Array.isArray(action.then)) {
                            action.then.forEach(a => {
                                if (a && a.id) {
                                    idsToDelete.add(a.id);
                                    collectNestedActionIds(a);
                                }
                            });
                        }
                        if (Array.isArray(action.else)) {
                            action.else.forEach(a => {
                                if (a && a.id) {
                                    idsToDelete.add(a.id);
                                    collectNestedActionIds(a);
                                }
                            });
                        }
                    } else if (isRepeatAction(action)) {
                        // Collect actions from do array
                        if (Array.isArray(action.do)) {
                            action.do.forEach(a => {
                                if (a && a.id) {
                                    idsToDelete.add(a.id);
                                    collectNestedActionIds(a);
                                }
                            });
                        }
                    }
                }
                
                const actionInfo = findActionLocation(deleteTargetId);
                if (actionInfo?.action) {
                    collectNestedActionIds(actionInfo.action);
                }
                
                // Remove the selected action (and its nested children) from wherever it lives
                removeActionById(deleteTargetId);
                
                // Clean up any stray nested references with matching IDs
                const pruneNestedArrays = (arr) => {
                    if (!Array.isArray(arr)) return;
                    for (let i = arr.length - 1; i >= 0; i--) {
                        const act = arr[i];
                        if (!act) continue;
                        if (idsToDelete.has(act.id)) {
                            arr.splice(i, 1);
                            continue;
                        }
                        if (isConditionalAction(act)) {
                            pruneNestedArrays(act.then);
                            pruneNestedArrays(act.else);
                        } else if (isRepeatAction(act)) {
                            pruneNestedArrays(act.do);
                        }
                    }
                };
	                pruneNestedArrays(currentActions);
	                commitActionChanges();
	            }
	            closeDeleteModal();
	        }

        function deleteAction(actionId) {
            showDeleteModal('action', actionId);
        }

	        function duplicateAction(actionId) {
	            const loc = findActionLocation(actionId);
	            if (!loc) return;
	            pushUndoState();
	            const newAction = cloneActionDeep(loc.action);
	            loc.parentArray.splice(loc.index + 1, 0, newAction);
	            commitActionChanges([newAction.id]);
	        }

	        function commitActionChanges(animateIds = null) {
	            currentActions = ensureActionUUIDs(currentActions);
	            if (currentProject) {
	                currentProject.actions = currentActions;
	                saveProjects();
	            }
	            renderActions(animateIds);
	            updateUndoRedoButtons();
	        }

        function scrollPreviewToBottom() {
            requestAnimationFrame(() => {
                const canvas = document.getElementById('preview-canvas');
                if (canvas) {
                    canvas.scrollTop = canvas.scrollHeight;
                }
            });
        }

	        // ============ Placement Helpers ============
	        function insertActionIntoZone(controlAction, sectionKey, movedAction, zoneEl, clientY) {
	            if (!controlAction || !movedAction) return;
	            const targetArray = ensureSectionArray(controlAction, sectionKey);
	            if (!targetArray) return;

	            // Determine insertion index based on cursor position vs visible children
	            let insertIndex = targetArray.length;
	            const contentEl = Array.from(zoneEl.children).find(c => c.classList?.contains('control-section-content')) || zoneEl;
	            const childNodes = Array.from(contentEl.children)
	                .filter(n =>
	                    n?.dataset?.id &&
	                    (n.classList?.contains('action-node') || n.classList?.contains('if-block') || n.classList?.contains('repeat-block'))
	                );
	            for (const child of childNodes) {
	                const childId = parseInt(child.dataset.id);
	                if (!Number.isFinite(childId)) continue;
	                const midY = child.getBoundingClientRect().top + child.getBoundingClientRect().height / 2;
	                if (clientY < midY) {
	                    const idx = targetArray.findIndex(a => a.id === childId);
	                    if (idx !== -1) {
	                        insertIndex = idx;
	                        break;
	                    }
	                }
	            }
	            targetArray.splice(insertIndex, 0, movedAction);
	        }

        function insertIntoRootByPosition(moved, clientY) {
            let targetIndex = currentActions.length;
            const container = document.getElementById('actions-container');
            if (container) {
                const rootNodes = Array.from(container.querySelectorAll('.action-node, .if-block, .repeat-block')).filter(n => !n.dataset.parentId && n.dataset.id);
                for (let i = 0; i < rootNodes.length; i++) {
                    const rect = rootNodes[i].getBoundingClientRect();
                    if (clientY < rect.top + rect.height / 2) {
                        const targetId = parseInt(rootNodes[i].dataset.actionId || rootNodes[i].dataset.id);
                        const loc = findActionLocation(targetId);
                        if (loc && loc.parentArray === currentActions) {
                            targetIndex = loc.index;
                            break;
                        }
                    }
                }
            }
            currentActions.splice(targetIndex, 0, moved);
        }

	        // ============ Reorder (Pointer Drag) ============
	        function initActionReordering() {
	            if (reorderListenersAttached) return;
	            const container = document.getElementById('actions-container');
	            if (!container) return;

	            reorderListenersAttached = true;

	            container.addEventListener('pointerdown', reorderOnPointerDown);
	            window.addEventListener('pointermove', reorderOnPointerMove, { passive: false });
	            window.addEventListener('pointerup', reorderOnPointerUp);
	            window.addEventListener('pointercancel', reorderOnPointerCancel);
	        }

	        function reorderOnPointerDown(e) {
	            if (!editMode) return;
	            if (reorderState) return;
	            if (e.pointerType === 'mouse' && e.button !== 0) return;

	            // Don't start a drag when the user is interacting with controls/inputs.
	            if (e.target.closest('input, textarea, select, button, a, [contenteditable="true"], .node-actions, .control-actions, .linked-output')) {
	                return;
	            }

	            const itemEl = e.target.closest('.action-node, .if-block, .repeat-block');
	            if (!itemEl?.dataset?.id) return;

	            // On touch devices, dragging anywhere conflicts with scroll. Keep touch drag on the handle.
	            if (e.pointerType === 'touch' && !e.target.closest('[data-reorder-handle="true"]')) {
	                return;
	            }

	            const actionId = Number(itemEl.dataset.id);
	            if (!Number.isFinite(actionId)) return;

	            const loc = findActionLocation(actionId);
	            if (!loc?.action) return;

	            const rect = itemEl.getBoundingClientRect();
		            reorderState = {
		                phase: 'pending',
		                pointerId: e.pointerId,
		                handleEl: itemEl,
		                draggedId: actionId,
		                draggedRoot: loc.action,
		                ghostEl: itemEl,
		                placeholderEl: null,
		                startX: e.clientX,
		                startY: e.clientY,
		                lastClientY: e.clientY,
		                moveDirY: 0,
		                offsetX: e.clientX - rect.left,
		                offsetY: e.clientY - rect.top,
		                width: rect.width,
		                height: rect.height,
		                currentZone: null
	            };

	            try {
	                itemEl.setPointerCapture(e.pointerId);
	            } catch (err) {}

	            e.preventDefault();
	        }

	        function reorderOnPointerMove(e) {
	            const state = reorderState;
	            if (!state) return;
	            if (e.pointerId !== state.pointerId) return;

		            if (state.phase === 'pending') {
		                const dx = e.clientX - state.startX;
		                const dy = e.clientY - state.startY;
		                if (Math.hypot(dx, dy) < 6) return;
		                state.moveDirY = dy;
		                state.lastClientY = e.clientY;
		                reorderBeginDrag(state);
		            }

		            if (state.phase !== 'dragging') return;

		            e.preventDefault();
		            const deltaY = e.clientY - (state.lastClientY ?? e.clientY);
		            if (Math.abs(deltaY) > 1) state.moveDirY = deltaY;
		            state.lastClientY = e.clientY;
		            reorderUpdateGhostPosition(state, e.clientX, e.clientY);
		            reorderAutoScrollPreview(e.clientY);
		            reorderUpdatePlaceholderPosition(state, e.clientX, e.clientY);
		        }

	        function reorderOnPointerUp(e) {
	            const state = reorderState;
	            if (!state) return;
	            if (e.pointerId !== state.pointerId) return;

	            reorderState = null;

	            try {
	                state.handleEl?.releasePointerCapture(state.pointerId);
	            } catch (err) {}

	            if (state.phase !== 'dragging' || !state.placeholderEl) {
	                return;
	            }

	            const placeholderEl = state.placeholderEl;
	            const listEl = placeholderEl.parentElement;
		            const zone =
		                placeholderEl.closest('.if-then.drop-zone, .if-else.drop-zone, .repeat-body.drop-zone') ||
		                document.getElementById('actions-container');
		            const targetInfo = reorderGetTargetInfo(zone);
		            const targetIndex = reorderGetPlaceholderIndex(listEl, placeholderEl);

		            const beforeState = captureWorkspaceState();
		            const moved = reorderApplyMove(state.draggedId, targetInfo, targetIndex, state.draggedRoot);
		            reorderCleanup(state);

		            if (moved) {
		                pushUndoSnapshot(beforeState);
		                commitActionChanges();
		            } else {
		                renderActions();
		            }
		        }

	        function reorderOnPointerCancel(e) {
	            const state = reorderState;
	            if (!state) return;
	            if (e.pointerId !== state.pointerId) return;

	            reorderState = null;
	            try {
	                state.handleEl?.releasePointerCapture(state.pointerId);
	            } catch (err) {}

	            if (state.phase !== 'dragging') {
	                return;
	            }

	            reorderCleanup(state);
	            renderActions();
	        }

	        function reorderBeginDrag(state) {
	            const placeholder = document.createElement('div');
	            placeholder.className = 'drag-placeholder';
	            placeholder.style.height = `${Math.max(24, state.height)}px`;
	            placeholder.style.boxSizing = 'border-box';
	            placeholder.style.pointerEvents = 'none';
	            placeholder.innerHTML = '<div class="drag-placeholder-inner"></div>';

	            state.placeholderEl = placeholder;

	            const parent = state.ghostEl.parentNode;
	            if (!parent) return;
	            parent.insertBefore(placeholder, state.ghostEl);

	            const ghost = state.ghostEl;
	            ghost.classList.add('dragging');
	            ghost.style.position = 'fixed';
	            ghost.style.left = '0px';
	            ghost.style.top = '0px';
	            ghost.style.width = `${state.width}px`;
	            ghost.style.height = `${state.height}px`;
	            ghost.style.boxSizing = 'border-box';
	            ghost.style.pointerEvents = 'none';
	            ghost.style.zIndex = '10000';
	            ghost.style.margin = '0';
	            ghost.style.cursor = 'grabbing';
	            ghost.style.opacity = '0.9';

	            document.body.appendChild(ghost);

	            state.phase = 'dragging';
	            reorderSetZonesActive(true);

	            reorderUpdateGhostPosition(state, state.startX, state.startY);
	            reorderUpdatePlaceholderPosition(state, state.startX, state.startY);
	        }

	        function reorderUpdateGhostPosition(state, clientX, clientY) {
	            const ghost = state?.ghostEl;
	            if (!ghost) return;
	            ghost.style.left = `${clientX - state.offsetX}px`;
	            ghost.style.top = `${clientY - state.offsetY}px`;
	        }

	        function reorderAutoScrollPreview(clientY) {
	            const canvas = document.getElementById('preview-canvas');
	            if (!canvas) return;

	            const rect = canvas.getBoundingClientRect();
	            const edge = 64;
	            const speed = 18;

	            if (clientY < rect.top + edge) {
	                canvas.scrollTop -= speed;
	            } else if (clientY > rect.bottom - edge) {
	                canvas.scrollTop += speed;
	            }
	        }

	        function reorderUpdatePlaceholderPosition(state, clientX, clientY) {
	            const placeholder = state.placeholderEl;
	            if (!placeholder) return;

	            const zone = reorderGetZoneFromPoint(clientX, clientY);
	            if (!zone) {
	                reorderSetZoneHover(state, null);
	                return;
	            }

	            // Disallow dropping into self or descendants.
	            const zoneParentId = zone.dataset?.actionId ? Number(zone.dataset.actionId) : null;
	            if (
	                zoneParentId &&
	                (zoneParentId === state.draggedId || actionContainsId(state.draggedRoot, zoneParentId))
	            ) {
	                reorderSetZoneHover(state, null);
	                return;
	            }

	            const contentEl = reorderGetZoneContent(zone);
	            if (!contentEl) return;

		            const beforeEl = reorderFindInsertBefore(contentEl, clientY, placeholder, state.moveDirY);
		            if (beforeEl) {
		                contentEl.insertBefore(placeholder, beforeEl);
		            } else {
		                reorderAppendPlaceholder(contentEl, placeholder);
		            }

	            reorderSetZoneHover(state, zone);
	        }

	        function reorderGetZoneFromPoint(clientX, clientY) {
	            const el = document.elementFromPoint(clientX, clientY);
	            if (!el) return null;

	            const nestedZone = el.closest('.if-then.drop-zone, .if-else.drop-zone, .repeat-body.drop-zone');
	            if (nestedZone) return nestedZone;

	            const actionsContainer = el.closest('#actions-container');
	            if (actionsContainer) return actionsContainer;

	            // If we're still in the preview canvas, treat as root drop.
	            if (el.closest('#preview-canvas')) {
	                return document.getElementById('actions-container');
	            }

	            return null;
	        }

	        function reorderGetZoneContent(zone) {
	            if (!zone) return null;
	            if (zone.id === 'actions-container') return zone;
	            return (
	                Array.from(zone.children).find(c => c.classList?.contains('control-section-content')) || zone
	            );
	        }

	        function reorderIsItemElement(el) {
	            return (
	                !!el?.classList &&
	                (el.classList.contains('action-node') || el.classList.contains('if-block') || el.classList.contains('repeat-block'))
	            );
	        }

		        function reorderFindInsertBefore(listEl, clientY, placeholderEl, dirY = 0) {
		            const items = Array.from(listEl.children).filter(el => reorderIsItemElement(el) && el !== placeholderEl);

		            if (!dirY) {
		                let closestOffset = Number.NEGATIVE_INFINITY;
		                let closestEl = null;

		                items.forEach(el => {
		                    const rect = el.getBoundingClientRect();
		                    const offset = clientY - (rect.top + rect.height / 2);
		                    if (offset < 0 && offset > closestOffset) {
		                        closestOffset = offset;
		                        closestEl = el;
		                    }
		                });

		                return closestEl;
		            }

		            for (let i = 0; i < items.length; i++) {
		                const el = items[i];
		                const rect = el.getBoundingClientRect();
		                if (clientY < rect.top + 2) return el;
		                if (clientY >= rect.top && clientY <= rect.bottom) {
		                    if (dirY < 0) return el;
		                    return items[i + 1] || null;
		                }
		            }

		            return null;
		        }

	        function reorderAppendPlaceholder(listEl, placeholderEl) {
	            const hintEl = Array.from(listEl.children).find(c => c.classList?.contains('empty-section-hint')) || null;
	            if (hintEl) {
	                listEl.insertBefore(placeholderEl, hintEl);
	            } else {
	                listEl.appendChild(placeholderEl);
	            }
	        }

	        function reorderSetZoneHover(state, zone) {
	            if (state.currentZone && state.currentZone !== zone) {
	                state.currentZone.classList.remove('drop-zone-hover');
	            }
	            state.currentZone = zone;
	            if (zone?.classList) {
	                zone.classList.add('drop-zone-hover');
	            }
	        }

	        function reorderSetZonesActive(active) {
	            const container = document.getElementById('actions-container');
	            if (!container) return;
	            container.querySelectorAll('.drop-zone').forEach(z => z.classList.toggle('drop-zone-active', active));
	        }

	        function reorderGetTargetInfo(zone) {
	            if (!zone) return null;

	            if (zone.id === 'actions-container') {
	                return { parentId: null, section: 'root' };
	            }

	            const parentId = Number(zone.dataset?.actionId);
	            if (!Number.isFinite(parentId)) return null;

	            const dropZone = zone.dataset?.dropZone;
	            const section =
	                dropZone === 'if-then' ? 'then' :
	                dropZone === 'if-else' ? 'else' :
	                dropZone === 'repeat' ? 'do' :
	                null;
	            if (!section) return null;

	            return { parentId, section };
	        }

	        function reorderGetPlaceholderIndex(listEl, placeholderEl) {
	            if (!listEl) return 0;
	            let index = 0;
	            for (const child of Array.from(listEl.children)) {
	                if (child === placeholderEl) break;
	                if (reorderIsItemElement(child)) index += 1;
	            }
	            return index;
	        }

	        function reorderApplyMove(actionId, targetInfo, targetIndex, draggedRoot) {
	            if (!targetInfo) return false;

	            const targetParentId = targetInfo.parentId ? Number(targetInfo.parentId) : null;
	            if (targetParentId && (targetParentId === actionId || actionContainsId(draggedRoot, targetParentId))) {
	                return false;
	            }

	            const moved = removeActionById(actionId);
	            if (!moved) return false;

	            let targetArray;
	            if (!targetParentId) {
	                targetArray = currentActions;
	            } else {
	                const parentLoc = findActionLocation(targetParentId);
	                targetArray = parentLoc?.action ? ensureSectionArray(parentLoc.action, targetInfo.section) : currentActions;
	            }

	            if (!Array.isArray(targetArray)) targetArray = currentActions;
	            if (typeof targetIndex !== 'number' || targetIndex < 0 || targetIndex > targetArray.length) {
	                targetIndex = targetArray.length;
	            }

	            targetArray.splice(targetIndex, 0, moved);
	            return true;
	        }

	        function reorderCleanup(state) {
	            reorderSetZonesActive(false);
	            if (state.currentZone) {
	                state.currentZone.classList.remove('drop-zone-hover');
	            }

	            if (state.placeholderEl?.parentNode) {
	                state.placeholderEl.parentNode.removeChild(state.placeholderEl);
	            }

	            if (state.ghostEl?.parentNode) {
	                state.ghostEl.parentNode.removeChild(state.ghostEl);
	            }
	        }
        // ============ Menus ============
        function togglePlusMenu() {
            const menu = document.getElementById('plus-menu');
            const btn = document.getElementById('plus-menu-btn');
            menu.classList.toggle('active');
            btn.classList.toggle('active');
        }

        function toggleProfileMenu() {
            document.getElementById('profile-menu')?.classList.toggle('active');
        }

        function setChatMode(mode) {
            chatMode = mode;
            document.getElementById('plus-menu')?.classList.remove('active');
            document.getElementById('plus-menu-btn')?.classList.remove('active');
            const input = document.getElementById('chat-input');
            if (mode === 'discussion') input.placeholder = 'Discussion mode...';
            else input.placeholder = 'Describe your shortcut...';
        }

        // ============ Force Action Modal ============
        async function loadTemplates() {
            try {
                const response = await fetch('Templates/index.json');
                const files = await response.json();
                availableTemplates = files.map(f => typeof f === 'string' ? { file: f, action: f.replace('.json', '') } : { file: f.file, action: f.file.replace('.json', '') });
            } catch (e) { console.error('Failed to load templates:', e); }
        }

        function openForceActionModal() {
            document.getElementById('plus-menu')?.classList.remove('active');
            document.getElementById('plus-menu-btn')?.classList.remove('active');
            document.getElementById('force-action-modal').classList.add('active');
            renderActionsList();
            const searchInput = document.getElementById('action-search');
            searchInput.value = '';
            searchInput.focus();
            searchInput.oninput = () => renderActionsList(searchInput.value);
        }

        function closeForceActionModal() {
            document.getElementById('force-action-modal').classList.remove('active');
        }

        function renderActionsList(filter = '') {
            const list = document.getElementById('actions-list');
            list.innerHTML = '';
            const term = filter.toLowerCase();
            const filtered = availableTemplates.filter(t => t.action.toLowerCase().includes(term));
            filtered.forEach(t => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.style.cssText = 'padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer;';
                item.innerHTML = `<div class="node-icon" style="width:32px;height:32px;">${getActionIcon(t.action)}</div><span>${escapeHtml(t.action)}</span>`;
                item.onclick = () => {
                    if (editMode) {
                        addActionDirectly(t);
                    } else {
                        addForcedAction(t);
                    }
                };
                list.appendChild(item);
            });
        }

        let placementMode = false;
        let pendingAction = null;
        let placementCursor = null;
        let placementMoveHandler = null;
        let placementClickHandler = null;
        let placementKeyHandler = null;

        async function addActionDirectly(template) {
            closeForceActionModal();
            try {
                const response = await fetch(`Templates/${template.file}`);
                let text = await response.text();
                // Remove comments (lines starting with # or //, or inline comments)
                text = text.split('\n').map(line => {
                    // Simple check: if line has # or //, check if it's inside quotes
                    let inString = false;
                    let result = '';
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
                            inString = !inString;
                        }
                        if (!inString && (char === '#' || (char === '/' && line[i + 1] === '/'))) {
                            // Found comment start outside string
                            break;
                        }
                        result += char;
                    }
                    return result;
                }).join('\n');
                // Try to parse as JSON
                let data;
                try {
                    data = JSON.parse(text);
                } catch (jsonErr) {
                    console.warn('JSON parse error, using fallback:', jsonErr);
                    data = { action: template.action, params: {} };
                }
                const newAction = { id: Date.now(), action: data.action || template.action, title: data.action || template.action, params: data.params || {} };
                getActionUUID(newAction);
                currentActions.push(newAction);
                commitActionChanges([newAction.id]);
                scrollPreviewToBottom();
            } catch (e) { console.error('Failed to load action template:', e); }
        }

        function enterPlacementMode(action) {
            placementMode = true;
            pendingAction = action;
            
            // Create floating cursor element
            if (placementCursor) placementCursor.remove();
            placementCursor = document.createElement('div');
            placementCursor.className = 'placement-cursor';
            placementCursor.innerHTML = `
                <div class="placement-cursor-content">
                    <div class="node-icon">${getActionIcon(action.action)}</div>
                    <span>${escapeHtml(action.title || action.action)}</span>
                    <span class="placement-hint">Click to place action</span>
                </div>
            `;
            document.body.appendChild(placementCursor);
            
            // Update cursor position on mouse move
            placementMoveHandler = (e) => {
                if (!placementMode) return;
                placementCursor.style.left = e.clientX + 'px';
                placementCursor.style.top = e.clientY + 'px';
                
                // Highlight drop zones - prioritize drop zones over action nodes
            const container = document.getElementById('actions-container');
            let allZones = Array.from(container.querySelectorAll('.drop-zone, .action-node, .if-block, .repeat-block, #actions-container, .root-drop-zone'));
            // Also include the preview canvas as a fallback
            const previewCanvas = document.getElementById('preview-canvas');
            if (previewCanvas) allZones.push(previewCanvas);
                let hoveredZone = null;
                
                allZones.forEach(zone => {
                    const rect = zone.getBoundingClientRect();
                    if (e.clientX >= rect.left && e.clientX <= rect.right &&
                        e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        // Prioritize drop zones
                        if (zone.classList.contains('drop-zone')) {
                            hoveredZone = zone;
                        } else if (!hoveredZone) {
                            hoveredZone = zone;
                        }
                    }
                });
                
                // Remove all hover classes first
                allZones.forEach(zone => zone.classList.remove('placement-hover'));
                // Add hover to the topmost/prioritized zone
                if (hoveredZone) {
                    hoveredZone.classList.add('placement-hover');
                }
            };
            
            document.addEventListener('mousemove', placementMoveHandler);
            
            // Handle click to place (use single click listener to avoid double fire)
	            placementClickHandler = (e) => {
	                if (!placementMode) return;
	                if (e.button !== 0) return;
	                if (!pendingAction) return;
	                pushUndoState();
	                
	                const container = document.getElementById('actions-container');
	                let allZones = Array.from(container.querySelectorAll('.drop-zone, .action-node, .if-block, .repeat-block, #actions-container'));
                // Also include the preview canvas as a fallback
                const previewCanvas = document.getElementById('preview-canvas');
                if (previewCanvas) allZones.push(previewCanvas);
                let placed = false;
                let targetZone = null;
                
                // Find the zone under the cursor, prioritizing drop zones
                allZones.forEach(zone => {
                    const rect = zone.getBoundingClientRect();
                    if (e.clientX >= rect.left && e.clientX <= rect.right &&
                        e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        if (zone.classList.contains('drop-zone')) {
                            targetZone = zone;
                            placed = true;
                        } else if (!targetZone) {
                            targetZone = zone;
                            placed = true;
                        }
                    }
                });
                
                if (targetZone) {
                    if (targetZone.classList.contains('drop-zone')) {
                        const actionId = parseInt(targetZone.dataset.actionId);
                        const dropZone = targetZone.dataset.dropZone;
                        const controlInfo = findActionLocation(actionId);
                        if (controlInfo?.action) {
                            const sectionKey = dropZone === 'if-then' ? 'then' : dropZone === 'if-else' ? 'else' : 'do';
                            insertActionIntoZone(controlInfo.action, sectionKey, pendingAction, targetZone, e.clientY);
                            placed = true;
                        }
                    } else if (targetZone.classList.contains('action-node') || targetZone.classList.contains('if-block') || targetZone.classList.contains('repeat-block')) {
                        // Place after the action node within same parent
                        const targetId = parseInt(targetZone.dataset.id || targetZone.dataset.actionId);
                        const targetInfo = findActionLocation(targetId);
                        if (targetInfo) {
                            const insertIndex = targetInfo.index + 1;
                            targetInfo.parentArray.splice(insertIndex, 0, pendingAction);
                            placed = true;
                        }
                    } else if (targetZone.id === 'actions-container' || targetZone.classList.contains('root-drop-zone')) {
                        insertIntoRootByPosition(pendingAction, e.clientY);
                        placed = true;
                    } else if (targetZone.id === 'preview-canvas') {
                        // Place at end when clicking on empty canvas area
                        currentActions.push(pendingAction);
                        placed = true;
                    }
                }
                
                if (!placed) {
                    // Place at end if no specific zone was detected
                    currentActions.push(pendingAction);
                }
                
                // Clean up
                exitPlacementMode();
                commitActionChanges([pendingAction.id]);
            };
            
            document.addEventListener('click', placementClickHandler);
            placementKeyHandler = (e) => {
                if (e.key === 'Escape') {
                    exitPlacementMode();
                }
            };
            document.addEventListener('keydown', placementKeyHandler, { once: true });
        }

        function exitPlacementMode() {
            placementMode = false;
            pendingAction = null;
            if (placementCursor) {
                placementCursor.remove();
                placementCursor = null;
            }
            if (placementMoveHandler) {
                document.removeEventListener('mousemove', placementMoveHandler);
                placementMoveHandler = null;
            }
            if (placementClickHandler) {
                document.removeEventListener('click', placementClickHandler, true);
                placementClickHandler = null;
            }
            if (placementKeyHandler) {
                document.removeEventListener('keydown', placementKeyHandler);
                placementKeyHandler = null;
            }
            document.getElementById('actions-container')?.querySelectorAll('.placement-hover').forEach(el => {
                el.classList.remove('placement-hover');
            });
        }

        // ============ Download ============
        function openDownloadModal() {
            document.getElementById('download-modal').classList.add('active');
        }

        function closeDownloadModal() {
            document.getElementById('download-modal').classList.remove('active');
            document.getElementById('download-status').style.display = 'none';
        }

        async function executeDownload(type) {
            if (currentActions.length === 0) {
                alert('No actions to download. Build your shortcut first!');
                return;
            }

            const statusEl = document.getElementById('download-status');
            const statusText = document.getElementById('download-status-text');
            statusEl.style.display = 'block';
            statusText.textContent = 'Converting to shortcut format...';

            try {
                const serializeActionForExport = (action) => {
                    if (!action || typeof action !== 'object') return action;
                    const out = {
                        action: action.action || action.title || 'Unknown',
                        params: clonePlainObject(action.params || {})
                    };
                    if (Array.isArray(action.then)) out.then = action.then.map(serializeActionForExport);
                    if (Array.isArray(action.else)) out.else = action.else.map(serializeActionForExport);
                    if (Array.isArray(action.do)) out.do = action.do.map(serializeActionForExport);
                    return out;
                };

                const serializeTreeForExport = (nodes) => {
                    if (!Array.isArray(nodes)) return [];
                    const out = [];
                    nodes.forEach((node) => {
                        if (!node) return;
                        if (node.type === 'if') {
                            const base = serializeActionForExport(node.action);
                            if (base?.params && base.params.WFControlFlowMode !== undefined) {
                                delete base.params.WFControlFlowMode;
                            }
                            base.then = serializeTreeForExport(node.children || []);
                            if (Array.isArray(node.elseChildren) && node.elseChildren.length) {
                                base.else = serializeTreeForExport(node.elseChildren);
                            }
                            out.push(base);
                            return;
                        }
                        if (node.type === 'repeat') {
                            const base = serializeActionForExport(node.action);
                            base.do = serializeTreeForExport(node.children || []);
                            out.push(base);
                            return;
                        }
                        out.push(serializeActionForExport(node.action));
                    });
                    return out;
                };

                // Build program object
                const programObj = {
                    name: currentProject?.name || 'My Shortcut',
                    actions: serializeTreeForExport(buildActionTree(currentActions || []))
                };

                // Convert to plist
                statusText.textContent = 'Generating plist...';
                const convertRes = await fetch(`${API_BASE}/convert`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(programObj)
                });
                const convertData = await convertRes.json();
                if (!convertData.ok) throw new Error(convertData.message || 'Conversion failed');

                // Sign the shortcut
                statusText.textContent = 'Signing shortcut...';
                const plistBlob = new Blob([convertData.plist], { type: 'application/xml' });
                const signRes = await fetch(`${API_BASE}/sign`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/octet-stream' },
                    body: plistBlob
                });

                if (!signRes.ok) {
                    throw new Error('Signing failed');
                }

                // Download
                statusText.textContent = 'Downloading...';
                const blob = await signRes.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${programObj.name.replace(/[^a-z0-9]/gi, '_')}.shortcut`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                closeDownloadModal();
            } catch (err) {
                console.error('Download error:', err);
                statusText.textContent = '‚ö†Ô∏è ' + (err.message || 'Download failed');
                setTimeout(() => { statusEl.style.display = 'none'; }, 3000);
            }
        }

        // ============ Resize Handle ============
        function initResizeHandle() {
            const chatPane = document.getElementById('chat-pane');
            const handle = document.getElementById('resize-handle');
            if (!chatPane || !handle) return;
            let isResizing = false;
            handle.addEventListener('mousedown', () => { isResizing = true; handle.classList.add('active'); document.body.style.cursor = 'col-resize'; });
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                let newWidth = e.clientX;
                if (newWidth < 320) newWidth = 320;
                if (newWidth > 600) newWidth = 600;
                chatPane.style.width = `${newWidth}px`;
            });
            document.addEventListener('mouseup', () => { isResizing = false; handle.classList.remove('active'); document.body.style.cursor = ''; });
        }

        // ============ Edit Mode ============
        function toggleEditMode() {
            editMode = !editMode;
            const btn = document.getElementById('edit-btn');
            const btnText = document.getElementById('edit-btn-text');
            const addBtn = document.getElementById('add-action-btn');
            if (editMode) {
                btn.classList.add('primary');
                btnText.textContent = 'Done';
                document.getElementById('actions-container')?.classList.add('edit-mode');
                if (addBtn) addBtn.style.display = 'flex';
            } else {
                btn.classList.remove('primary');
                btnText.textContent = 'Edit';
                document.getElementById('actions-container')?.classList.remove('edit-mode');
                if (addBtn) addBtn.style.display = 'none';
            }
            updateUndoRedoButtons();
            renderActions();
        }

        // ============ Pipeline Orbs (in chat) ============
        const PIPELINE_STEPS = [
            { id: 'plan', label: 'Planning', hint: 'Analyzing your request...' },
            { id: 'catalog', label: 'Searching', hint: 'Finding matching actions...' },
            { id: 'build', label: 'Building', hint: 'Assembling your shortcut...' },
            { id: 'summarize', label: 'Finalizing', hint: 'Polishing results...' }
        ];

	        const MIN_PIPELINE_ACTIVE_MS = 350;
	        const pipelineStepStartedAt = new Map();
	        const pipelineStepCompleteTimers = new Map();
	        let currentPipelineStep = null;
	        let pipelinePendingStartTimer = null;

	        function clearPipelinePendingStart() {
	            if (pipelinePendingStartTimer) {
	                clearTimeout(pipelinePendingStartTimer);
	                pipelinePendingStartTimer = null;
	            }
	        }

	        function clearPipelineStepTimer(step) {
	            const t = pipelineStepCompleteTimers.get(step);
	            if (t) {
	                clearTimeout(t);
	                pipelineStepCompleteTimers.delete(step);
	            }
	        }

	        function showPipelineOrbs() {
	            const container = document.getElementById('messages');
	            const existing = document.getElementById('pipeline-orbs');
	            if (existing) existing.remove();

	            const orbsDiv = document.createElement('div');
	            orbsDiv.id = 'pipeline-orbs';
	            orbsDiv.className = 'pipeline-orbs';
	            orbsDiv.innerHTML = `
	                <div class="pipeline-orbs-row" role="group" aria-label="Generation progress">
	                    ${PIPELINE_STEPS.map((step, idx) => `
	                        <div class="orb" id="orb-${step.id}" data-orb-step="${step.id}">
	                            <span>${step.label}</span>
	                        </div>
	                        ${idx < PIPELINE_STEPS.length - 1 ? '<div class="orb-line" aria-hidden="true"></div>' : ''}
	                    `).join('')}
	                </div>
	                <div class="pipeline-orbs-hint" id="pipeline-orbs-hint">${escapeHtml(PIPELINE_STEPS[0]?.hint || 'Working...')}</div>
	            `;
	            container.appendChild(orbsDiv);
	            container.scrollTop = container.scrollHeight;
	            resetPipelineSteps();
	            updatePipelineProgress('assess', 'started', 'Analyzing your request...');
	        }

	        function updatePipelineOrb(step, status, hint = '') {
	            const orb = document.getElementById(`orb-${step}`);
	            if (!orb) return;
	            orb.classList.remove('active', 'completed');
	            if (status === 'started') orb.classList.add('active');
	            else if (status === 'completed') orb.classList.add('completed');

	            const hintEl = document.getElementById('pipeline-orbs-hint');
	            if (hintEl && (status === 'started' || hint)) {
	                const state = status === 'completed' ? 'completed' : status === 'started' ? 'active' : 'idle';
	                hintEl.textContent = hint || getDefaultHint(step, state);
	            }
	        }
        
        function getDefaultHint(step, state = 'idle') {
            const meta = PIPELINE_STEPS.find(s => s.id === step);
            if (state === 'completed') return 'Done';
            if (state === 'active') return meta?.hint || 'In progress...';
            return 'Waiting...';
        }

	        function removePipelineOrbs() {
	            clearPipelinePendingStart();
	            currentPipelineStep = null;
	            pipelineStepStartedAt?.clear?.();
	            if (pipelineStepCompleteTimers && typeof pipelineStepCompleteTimers.forEach === 'function') {
	                pipelineStepCompleteTimers.forEach((t) => { try { clearTimeout(t); } catch (e) { } });
	                pipelineStepCompleteTimers.clear();
	            }
	            document.getElementById('pipeline-orbs')?.remove();
	        }

        // ============ Forced Actions ============
        async function addForcedAction(template) {
            closeForceActionModal();
            if (forcedActions.find(a => a.action === template.action)) return; // Already forced
            forcedActions.push({ action: template.action, file: template.file });
            renderForcedActions();
            addMessageToUI(`üéØ Will use **${template.action}** in next response`, 'assistant');
        }

        function removeForcedAction(action) {
            forcedActions = forcedActions.filter(a => a.action !== action);
            renderForcedActions();
        }

        function renderForcedActions() {
            const container = document.getElementById('forced-actions');
            if (!container) return;
            if (forcedActions.length === 0) {
                container.innerHTML = '';
                container.style.display = 'none';
                return;
            }
            container.style.display = 'flex';
            container.innerHTML = forcedActions.map(a => `
                <div class="forced-action-pill">
                    <span>${escapeHtml(a.action)}</span>
                    <button onclick="removeForcedAction('${escapeHtml(a.action)}')">&times;</button>
                </div>
            `).join('');
        }

        // ============ Mode Toggle (in plus menu) ============
        function toggleMode(mode) {
            if (chatMode === mode) {
                chatMode = 'standard';
            } else {
                chatMode = mode;
            }
            updateModeIndicators();
            setChatMode(chatMode);
            // Don't close menu - let user see the state change
        }

        function updateModeIndicators() {
            const discussionToggle = document.getElementById('discussion-mode-toggle');

            discussionToggle?.classList.toggle('active', chatMode === 'discussion');
        }

        // ============ Animations Toggle ============
        function toggleAnimations() {
            animationsEnabled = !animationsEnabled;
            localStorage.setItem('flux_animations', animationsEnabled ? 'enabled' : 'disabled');
            document.body.classList.toggle('no-animations', !animationsEnabled);
            const text = document.getElementById('animations-toggle-text');
            if (text) text.textContent = animationsEnabled ? 'Disable Animations' : 'Enable Animations';
            document.getElementById('profile-menu')?.classList.remove('active');
        }

        function initAnimations() {
            if (!animationsEnabled) {
                document.body.classList.add('no-animations');
                const text = document.getElementById('animations-toggle-text');
                if (text) text.textContent = 'Enable Animations';
            }
        }

        // ============ Context Menu (Right Click / Variable Insert) ============
        function showVariableMenu(event, inputEl) {
            event.preventDefault();
            contextMenuTarget = inputEl;
            const menu = document.getElementById('variable-context-menu');

            // Build dynamic menu with linkable actions
            let menuHtml = '<div class="context-menu-header">Insert Variable</div>';
            menuHtml += '<div class="context-menu-item" onclick="insertVariable(\'Shortcut Input\')">üì• Shortcut Input</div>';
            menuHtml += '<div class="context-menu-item" onclick="insertVariable(\'Clipboard\')">üìã Clipboard</div>';
            menuHtml += '<div class="context-menu-item" onclick="insertVariable(\'Current Date\')">üìÖ Current Date</div>';
            menuHtml += '<div class="context-menu-item" onclick="insertVariable(\'Device Name\')">üì± Device Name</div>';
            menuHtml += '<div class="context-menu-item" onclick="insertVariable(\'Ask Each Time\')">‚ùì Ask Each Time</div>';

            // Add linkable actions (outputs from previous actions in order)
            const currentActionId = parseInt(inputEl.dataset.actionId);
            const flatActions = flattenActions();
            const currentIndex = flatActions.findIndex(a => a.id === currentActionId);
            const previousActions = currentIndex > 0 ? flatActions.slice(0, currentIndex) : [];
            const linkableActions = previousActions
                .map(a => ({ action: a, output: getActionOutputInfo(a) }))
                .filter(entry => entry.output);
            if (linkableActions.length > 0) {
                menuHtml += '<div class="context-menu-divider"></div>';
                menuHtml += '<div class="context-menu-header">Link to Action</div>';
                linkableActions.forEach(({ action: a, output }) => {
                    const uuid = output.outputUUID;
                    const label = output.outputName || a.title || a.action || 'Action';
                    const safeLabel = escapeHtml(label).replace(/\"/g, '&quot;');
                    menuHtml += `<div class="context-menu-item" data-source-id="${a.id}" data-source-uuid="${uuid || ''}" data-source-label="${safeLabel}">üîó ${escapeHtml(label)}</div>`;
                });
            }

            menu.innerHTML = menuHtml;

            // Position menu - ensure it doesn't go off screen
            let x = event.pageX;
            let y = event.pageY;
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');

            // Wire link clicks
            const linkItems = menu.querySelectorAll('[data-source-id]');
            linkItems.forEach(item => {
                item.addEventListener('click', () => {
                    const sourceId = parseInt(item.getAttribute('data-source-id'));
                    linkActionParam(currentActionId, inputEl.dataset.param, sourceId, item.getAttribute('data-source-uuid'), item.getAttribute('data-source-label'));
                });
            });

            // Adjust if going off bottom
            setTimeout(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = (y - rect.height) + 'px';
                }
                if (rect.right > window.innerWidth) {
                    menu.style.left = (x - rect.width) + 'px';
                }
            }, 0);
        }

        function initContextMenu() {
            document.addEventListener('click', () => {
                document.getElementById('variable-context-menu')?.classList.remove('active');
            });
        }

        function insertVariable(varName) {
            if (!contextMenuTarget) return;
            const start = contextMenuTarget.selectionStart || contextMenuTarget.value.length;
            const end = contextMenuTarget.selectionEnd || contextMenuTarget.value.length;
            const text = contextMenuTarget.value;
            const varText = `{{${varName}}}`;
            contextMenuTarget.value = text.slice(0, start) + varText + text.slice(end);
            contextMenuTarget.focus();
            contextMenuTarget.setSelectionRange(start + varText.length, start + varText.length);
            contextMenuTarget.dispatchEvent(new Event('change'));
            document.getElementById('variable-context-menu')?.classList.remove('active');
        }

	        function linkActionParam(targetId, paramKey, sourceId, sourceUuid, sourceLabel) {
	            const targetInfo = findActionLocation(targetId);
	            const sourceInfo = findActionLocation(sourceId);
	            const target = targetInfo?.action;
	            const source = sourceInfo?.action;
	            if (!target || !source) return;

	            const sourceOutput = getActionOutputInfo(source);
	            const outputUUID = sourceUuid ? String(sourceUuid) : sourceOutput?.outputUUID;
	            const outputName = sourceLabel || sourceOutput?.outputName || 'Previous Output';

	            // Only allow linking when the source exposes an output
	            const availableOutputs = collectAvailableOutputs();
	            if (!outputUUID || !availableOutputs.has(String(outputUUID))) {
	                console.warn('Link aborted: source action has no output to link.');
	                clearLinkedParam(targetId, paramKey);
	                return;
	            }

	            if (!target.params) target.params = {};
	            const existing = target.params[paramKey];
	            const existingUuid = existing?.Value?.OutputUUID || existing?.OutputUUID || '';
	            if (existingUuid && String(existingUuid) === String(outputUUID)) {
	                return;
	            }
	            pushUndoState();
	            target.params[paramKey] = {
	                Value: {
	                    OutputName: outputName,
	                    OutputUUID: outputUUID, // Use the same UUID as source
	                    Type: 'ActionOutput'
	                },
	                WFSerializationType: 'WFTextTokenAttachment'
	            };
	            commitActionChanges([targetId, sourceId]);
	        }

	        function clearLinkedParam(actionId, paramKey) {
	            const action = findActionLocation(actionId)?.action;
	            if (!action) return;
	            const fallback = buildParamPlaceholder(paramKey);
	            if (!action.params) action.params = {};
	            if (action.params[paramKey] === fallback) return;
	            pushUndoState();
	            action.params[paramKey] = fallback;
	            commitActionChanges([actionId]);
	        }

        // Mobile: add button to insert variable
        function addVariableInsertButton(inputEl) {
            // Check if on touch device
            if ('ontouchstart' in window) {
                const btn = document.createElement('button');
                btn.className = 'insert-var-btn';
                btn.innerHTML = '{}';
                btn.title = 'Insert Variable';
                btn.onclick = (e) => {
                    e.preventDefault();
                    showVariableMenu(e, inputEl);
                };
                inputEl.parentElement.appendChild(btn);
            }
        }

        // ============ Tutorial System ============
        const tutorialSteps = [
            { target: '#chat-input', title: 'Chat Input', text: 'Describe the shortcut you want to build. The AI will create it for you!' },
            { target: '#plus-menu-btn', title: 'Quick Actions', text: 'Click here to access Force Action and Discussion Mode. Modes turn blue when active.' },
            { target: '#preview-canvas', title: 'Shortcut Preview', text: 'Your shortcut actions will appear here. Click Edit to drag and reorder them!' },
            { target: '#edit-btn', title: 'Edit Mode', text: 'Click Edit to modify, add, or remove actions. You can also right-click inputs to insert variables.' },
            { target: '#top-download-btn', title: 'Download', text: 'When you\'re done, download your shortcut to use in the Shortcuts app!' }
        ];

        function startTutorial() {
            tutorialStep = 0;
            document.getElementById('profile-menu')?.classList.remove('active');
            showTutorialStep();
        }

        function showTutorialStep() {
            const overlay = document.getElementById('tutorial-overlay');
            const spotlight = document.getElementById('tutorial-spotlight');
            const popup = document.getElementById('tutorial-popup');
            const title = document.getElementById('tutorial-title');
            const text = document.getElementById('tutorial-text');
            const indicator = document.getElementById('tutorial-indicator');
            const nextBtn = document.getElementById('tutorial-next');

            if (tutorialStep >= tutorialSteps.length) {
                skipTutorial();
                return;
            }

            const step = tutorialSteps[tutorialStep];
            const targetEl = document.querySelector(step.target);

            overlay.classList.add('active');
            title.textContent = step.title;
            text.textContent = step.text;
            indicator.innerHTML = tutorialSteps.map((_, i) => `<span class="${i === tutorialStep ? 'active' : ''}"></span>`).join('');
            nextBtn.textContent = tutorialStep === tutorialSteps.length - 1 ? 'Done' : 'Next';

            if (targetEl) {
                const rect = targetEl.getBoundingClientRect();
                spotlight.style.left = (rect.left - 10) + 'px';
                spotlight.style.top = (rect.top - 10) + 'px';
                spotlight.style.width = (rect.width + 20) + 'px';
                spotlight.style.height = (rect.height + 20) + 'px';
                spotlight.style.display = 'block';

                // Position popup near target
                const popupWidth = 320;
                const popupHeight = 250; // Safe estimate
                const margin = 20;

                // Horizontal positioning
                let left = rect.left;
                // Clamp left to be within screen
                left = Math.max(margin, Math.min(left, window.innerWidth - popupWidth - margin));
                popup.style.left = left + 'px';

                // Vertical positioning
                let top = rect.bottom + margin;

                // Check if it fits below
                if (top + popupHeight > window.innerHeight - margin) {
                    // Try above
                    const topAbove = rect.top - popupHeight - margin;
                    if (topAbove > margin) {
                        top = topAbove;
                    } else {
                        // If neither fits perfectly, put it where there is more space
                        const spaceBelow = window.innerHeight - rect.bottom;
                        const spaceAbove = rect.top;
                        if (spaceAbove > spaceBelow) {
                            top = Math.max(margin, topAbove); // Clamp to top edge
                        } else {
                            top = Math.min(window.innerHeight - popupHeight - margin, top); // Clamp to bottom edge
                        }
                    }
                }
                popup.style.top = top + 'px';
            }
        }

        function nextTutorialStep() {
            tutorialStep++;
            showTutorialStep();
        }

        function skipTutorial() {
            document.getElementById('tutorial-overlay').classList.remove('active');
            localStorage.setItem('flux_tutorial_done', 'true');
            hasCompletedTutorial = true;
        }

        function checkFirstTimeTutorial() {
            if (!hasCompletedTutorial && currentProject) {
                // Check if this is their first ever project
                const allProjects = JSON.parse(localStorage.getItem('flux_projects')) || [];
                if (allProjects.length === 1) {
                    setTimeout(() => startTutorial(), 500);
                }
            }
        }

        // ============ View Updates ============
        function updateViewButtons() {
            const downloadBtn = document.getElementById('top-download-btn');
            const inWorkspace = !document.getElementById('workspace-view').classList.contains('hidden');
            if (downloadBtn) {
                downloadBtn.style.display = inWorkspace ? 'flex' : 'none';
            }
        }

        // Update showProjectsView and showWorkspaceView
        const originalShowProjectsView = showProjectsView;
        showProjectsView = function () {
            document.getElementById('projects-view').classList.remove('hidden');
            document.getElementById('workspace-view').classList.add('hidden');
            window.history.replaceState({}, '', 'app.html');
            renderProjectsGrid();
            updateViewButtons();
        };

        const originalShowWorkspaceView = showWorkspaceView;
        showWorkspaceView = function () {
            document.getElementById('projects-view').classList.add('hidden');
            document.getElementById('workspace-view').classList.remove('hidden');
            updateViewButtons();
        };

        // Initialize new features
        document.addEventListener('DOMContentLoaded', () => {
            initAnimations();
            initContextMenu();
            updateModeIndicators();
            renderForcedActions();
        });
    </script>
</body>

</html>
